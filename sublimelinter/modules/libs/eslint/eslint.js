// Generated by CommonJS Everywhere 0.9.4
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  var process = function () {
      var cwd = '/';
      return {
        title: 'browser',
        version: 'v0.10.12',
        browser: true,
        env: {},
        argv: [],
        nextTick: global.setImmediate || function (fn) {
          setTimeout(fn, 0);
        },
        cwd: function () {
          return cwd;
        },
        chdir: function (dir) {
          cwd = dir;
        }
      };
    }();
  require.define('/lib/eslint.js', function (module, exports, __dirname, __filename) {
    var esprima = require('/node_modules/esprima/esprima.js', module), estraverse = require('/node_modules/estraverse/estraverse.js', module), escope = require('/node_modules/escope/escope.js', module), environments = require('/conf/environments.json', module), rules = require('/lib/rules.js', module), util = require('/lib/util.js', module), RuleContext = require('/lib/rule-context.js', module), EventEmitter = require('events', module).EventEmitter;
    function escapeRegExp(rx) {
      return rx.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    }
    function forEachOption(string, callback) {
      string = string.replace(/\s*:\s*/g, ':');
      string = string.replace(/\s*,\s*/g, ',');
      string.split(/\s|,+/).forEach(function (name) {
        if (!name) {
          return;
        }
        var pos = name.indexOf(':'), value;
        if (pos !== -1) {
          value = name.substring(pos + 1, name.length);
          name = name.substring(0, pos);
        }
        callback(name, value);
      });
    }
    function parseBoolean(str) {
      return str === 'true';
    }
    function parseComment(comment, declaredGlobals) {
      if (comment.type !== 'Block') {
        return;
      }
      var text = comment.value;
      var match;
      if (match = /^\s*(globals?)/.exec(text)) {
        forEachOption(text.substring(match.index + match[1].length), function (name, value) {
          declaredGlobals[name] = parseBoolean(value);
        });
        return true;
      } else if (match = /^\s*(js[lh]int)/.exec(text)) {
        forEachOption(text.substring(match.index + match[1].length), function (name, value) {
          if (parseBoolean(value) && Object.hasOwnProperty.call(environments, name)) {
            util.mixin(declaredGlobals, environments[name]);
          }
        });
      }
    }
    function getVariable(scope, name) {
      var variable = null;
      scope.variables.some(function (v) {
        if (v.name === name) {
          variable = v;
          return true;
        }
        return false;
      });
      return variable;
    }
    function addDeclaredGlobals(program, globalScope, config) {
      var declaredGlobals = {}, builtin = environments.builtin;
      Object.keys(builtin).forEach(function (name) {
        declaredGlobals[name] = builtin[name];
      });
      if (config.env) {
        Object.keys(config.env).forEach(function (name) {
          var environment = environments[name];
          if (config.env[name] && environment) {
            Object.keys(environment).forEach(function (name) {
              declaredGlobals[name] = environment[name];
            });
          }
        });
      }
      program.comments.forEach(function (comment) {
        parseComment(comment, declaredGlobals);
      });
      if (config.globals) {
        Object.keys(config.globals).forEach(function (name) {
          declaredGlobals[name] = config.globals[name];
        });
      } else if (config.global) {
        Object.keys(config.global).forEach(function (name) {
          declaredGlobals[name] = config.global[name];
        });
      }
      Object.keys(declaredGlobals).forEach(function (name) {
        var variable = getVariable(globalScope, name);
        if (!variable) {
          variable = new escope.Variable(name, globalScope);
          globalScope.variables.push(variable);
        }
        variable.writeable = declaredGlobals[name];
      });
    }
    function modifyRulesFromComments(ast, config) {
      var rules = {};
      ast.comments.forEach(function (comment) {
        if (comment.type === 'Block') {
          var value = comment.value.trim();
          if (value.indexOf('eslint') === 0) {
            value = value.substr(6, value.length - 6);
            forEachOption(value, function (name, value) {
              rules[name] = JSON.parse(value);
            });
          }
        }
      });
      var newConfig = util.mergeConfigs(config.rules, rules);
      return newConfig;
    }
    module.exports = function () {
      var api = Object.create(new EventEmitter), messages = [], commentsAttached = false, currentText = null, currentConfig = null, currentTokens = null, currentScopes = null, controller = null;
      api.reset = function () {
        this.removeAllListeners();
        messages = [];
        commentsAttached = false;
        currentConfig = null;
        currentText = null;
        currentTokens = null;
        currentScopes = null;
        controller = null;
      };
      api.verify = function (text, config, saveState) {
        var ast, parseError = false;
        if (!saveState) {
          this.reset();
        }
        try {
          ast = esprima.parse(text, {
            loc: true,
            range: true,
            raw: true,
            tokens: true,
            comment: true
          });
        } catch (ex) {
          parseError = true;
          messages.push({
            fatal: true,
            message: ex.message.substring(ex.message.indexOf(':') + 1).trim(),
            line: ex.lineNumber,
            column: ex.column
          });
        }
        if (!parseError) {
          config.rules = modifyRulesFromComments(ast, config);
          Object.keys(config.rules).filter(function (key) {
            if (typeof config.rules[key] === 'number') {
              return config.rules[key] > 0;
            } else if (Array.isArray(config.rules[key])) {
              return config.rules[key][0] > 0;
            }
          }).forEach(function (key) {
            var ruleCreator = rules.get(key), options = [], rule;
            if (Array.isArray(config.rules[key])) {
              options = config.rules[key].slice(1);
            }
            if (ruleCreator) {
              rule = ruleCreator(new RuleContext(key, api, options));
              Object.keys(rule).forEach(function (nodeType) {
                api.on(nodeType, rule[nodeType]);
              });
            } else {
              throw new Error("Definition for rule '" + key + "' was not found.");
            }
          });
          currentConfig = config;
          currentText = text;
          controller = new estraverse.Controller;
          currentScopes = escope.analyze(ast, { ignoreEval: true }).scopes;
          currentTokens = {};
          ast.tokens.forEach(function (token) {
            currentTokens[token.range[0]] = token;
          });
          addDeclaredGlobals(ast, currentScopes[0], currentConfig);
          controller.traverse(ast, {
            enter: function (node) {
              api.emit(node.type, node);
            },
            leave: function (node) {
              api.emit(node.type + ':after', node);
            }
          });
        }
        return messages;
      };
      api.report = function (ruleId, node, message, opts) {
        Object.keys(opts || {}).forEach(function (key) {
          var rx = new RegExp('{{' + escapeRegExp(key) + '}}', 'g');
          message = message.replace(rx, opts[key]);
        });
        messages.push({
          ruleId: ruleId,
          node: node,
          message: message,
          line: node.loc.start.line,
          column: node.loc.start.column,
          source: api.getSource(node)
        });
      };
      api.getSource = function (node, beforeCount, afterCount) {
        if (node) {
          return currentText ? currentText.slice(node.range[0] - (beforeCount || 0), node.range[1] + (afterCount || 0)) : null;
        } else {
          return currentText || null;
        }
      };
      api.getAllComments = function () {
        return controller.root.comments || [];
      };
      api.getComments = function (node) {
        var ast = controller.root;
        if (!commentsAttached) {
          estraverse.attachComments(ast, ast.comments, ast.tokens);
          commentsAttached = true;
        }
        return {
          leading: node.leadingComments || [],
          trailing: node.trailingComments || []
        };
      };
      api.getTokens = function (node, beforeCount, afterCount) {
        if (node) {
          var startLocation = node.range[0] - (beforeCount || 0);
          var endLocation = node.range[1] + (afterCount || 0);
          var tokens = [];
          while (startLocation < endLocation) {
            if (currentTokens[startLocation]) {
              tokens.push(currentTokens[startLocation]);
              startLocation = currentTokens[startLocation].range[1];
            } else {
              startLocation += 1;
            }
          }
          return tokens;
        } else {
          return Object.keys(currentTokens).map(function (item) {
            return item;
          }) || null;
        }
      };
      api.getAncestors = function () {
        return controller.parents();
      };
      api.getScope = function () {
        var parents = controller.parents().reverse(), innerScope = null;
        if (parents.length) {
          var current = controller.current();
          if (current.type === 'FunctionDeclaration' || current.type === 'FunctionExpression') {
            parents.splice(0, 0, current);
          }
          for (var i = 0; i < parents.length; i++) {
            if (escope.Scope.isScopeRequired(parents[i])) {
              innerScope = parents[i];
              break;
            }
          }
          for (var j = 0; j < currentScopes.length; j++) {
            if (innerScope.type === currentScopes[j].block.type && innerScope.range[0] === currentScopes[j].block.range[0] && innerScope.range[1] === currentScopes[j].block.range[1]) {
              return currentScopes[j];
            }
          }
        } else {
          return currentScopes[0];
        }
      };
      var defineRule = api.defineRule = function (ruleId, ruleModule) {
          rules.define(ruleId, ruleModule);
        };
      api.defineRules = function (rules) {
        Object.getOwnPropertyNames(rules).forEach(function (ruleId) {
          defineRule(ruleId, rules[ruleId]);
        });
      };
      api.defaults = function () {
        return require('/conf/eslint.json', module);
      };
      return api;
    }();
  });
  require.define('/conf/eslint.json', function (module, exports, __dirname, __filename) {
    module.exports = {
      'env': {
        'browser': false,
        'node': false,
        'amd': false
      },
      'rules': {
        'no-alert': 2,
        'no-caller': 2,
        'no-bitwise': 0,
        'no-catch-shadow': 2,
        'no-console': 2,
        'no-comma-dangle': 2,
        'no-control-regex': 2,
        'no-debugger': 2,
        'no-div-regex': 0,
        'no-dupe-keys': 2,
        'no-else-return': 0,
        'no-empty': 2,
        'no-empty-class': 2,
        'no-eq-null': 0,
        'no-eval': 2,
        'no-ex-assign': 2,
        'no-func-assign': 2,
        'no-floating-decimal': 0,
        'no-implied-eval': 2,
        'no-with': 2,
        'no-fallthrough': 2,
        'no-global-strict': 2,
        'no-unreachable': 2,
        'no-undef': 2,
        'no-undef-init': 2,
        'no-unused-expressions': 2,
        'no-octal': 2,
        'no-octal-escape': 2,
        'no-obj-calls': 2,
        'no-multi-str': 2,
        'no-new-wrappers': 2,
        'no-new': 2,
        'no-new-func': 2,
        'no-native-reassign': 2,
        'no-plusplus': 0,
        'no-delete-var': 2,
        'no-return-assign': 2,
        'no-new-array': 2,
        'no-new-object': 2,
        'no-label-var': 2,
        'no-ternary': 0,
        'no-self-compare': 0,
        'no-spaced-func': 1,
        'no-sync': 0,
        'no-underscore-dangle': 2,
        'no-loop-func': 2,
        'no-empty-label': 2,
        'no-unused-vars': 2,
        'no-script-url': 2,
        'no-proto': 2,
        'no-iterator': 2,
        'no-mixed-requires': [
          0,
          false
        ],
        'no-wrap-func': 2,
        'no-shadow': 2,
        'no-use-before-define': 2,
        'no-redeclare': 2,
        'no-negated-in-lhs': 2,
        'brace-style': 0,
        'block-scoped-var': 0,
        'camelcase': 2,
        'complexity': [
          0,
          11
        ],
        'consistent-this': [
          0,
          'that'
        ],
        'curly': 2,
        'dot-notation': 2,
        'eqeqeq': 2,
        'guard-for-in': 0,
        'max-depth': [
          0,
          4
        ],
        'max-len': [
          0,
          80,
          4
        ],
        'max-params': [
          0,
          3
        ],
        'max-statements': [
          0,
          10
        ],
        'new-cap': 2,
        'new-parens': 2,
        'one-var': 0,
        'quotes': [
          2,
          'double'
        ],
        'quote-props': 0,
        'radix': 0,
        'regex-spaces': 2,
        'semi': 2,
        'strict': 2,
        'unnecessary-strict': 2,
        'use-isnan': 2,
        'wrap-iife': 0,
        'wrap-regex': 0
      }
    };
  });
  require.define('events', function (module, exports, __dirname, __filename) {
    if (!process.EventEmitter)
      process.EventEmitter = function () {
      };
    var EventEmitter = exports.EventEmitter = process.EventEmitter;
    var isArray = typeof Array.isArray === 'function' ? Array.isArray : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
      };
    ;
    var defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function (n) {
      if (!this._events)
        this._events = {};
      this._events.maxListeners = n;
    };
    EventEmitter.prototype.emit = function (type) {
      if (type === 'error') {
        if (!this._events || !this._events.error || isArray(this._events.error) && !this._events.error.length) {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
          return false;
        }
      }
      if (!this._events)
        return false;
      var handler = this._events[type];
      if (!handler)
        return false;
      if (typeof handler == 'function') {
        switch (arguments.length) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          var args = Array.prototype.slice.call(arguments, 1);
          handler.apply(this, args);
        }
        return true;
      } else if (isArray(handler)) {
        var args = Array.prototype.slice.call(arguments, 1);
        var listeners = handler.slice();
        for (var i = 0, l = listeners.length; i < l; i++) {
          listeners[i].apply(this, args);
        }
        return true;
      } else {
        return false;
      }
    };
    EventEmitter.prototype.addListener = function (type, listener) {
      if ('function' !== typeof listener) {
        throw new Error('addListener only takes instances of Function');
      }
      if (!this._events)
        this._events = {};
      this.emit('newListener', type, listener);
      if (!this._events[type]) {
        this._events[type] = listener;
      } else if (isArray(this._events[type])) {
        if (!this._events[type].warned) {
          var m;
          if (this._events.maxListeners !== undefined) {
            m = this._events.maxListeners;
          } else {
            m = defaultMaxListeners;
          }
          if (m && m > 0 && this._events[type].length > m) {
            this._events[type].warned = true;
            console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
            console.trace();
          }
        }
        this._events[type].push(listener);
      } else {
        this._events[type] = [
          this._events[type],
          listener
        ];
      }
      return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function (type, listener) {
      var self = this;
      self.on(type, function g() {
        self.removeListener(type, g);
        listener.apply(this, arguments);
      });
      return this;
    };
    EventEmitter.prototype.removeListener = function (type, listener) {
      if ('function' !== typeof listener) {
        throw new Error('removeListener only takes instances of Function');
      }
      if (!this._events || !this._events[type])
        return this;
      var list = this._events[type];
      if (isArray(list)) {
        var i = list.indexOf(listener);
        if (i < 0)
          return this;
        list.splice(i, 1);
        if (list.length == 0)
          delete this._events[type];
      } else if (this._events[type] === listener) {
        delete this._events[type];
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function (type) {
      if (type && this._events && this._events[type])
        this._events[type] = null;
      return this;
    };
    EventEmitter.prototype.listeners = function (type) {
      if (!this._events)
        this._events = {};
      if (!this._events[type])
        this._events[type] = [];
      if (!isArray(this._events[type])) {
        this._events[type] = [this._events[type]];
      }
      return this._events[type];
    };
  });
  require.define('/lib/rule-context.js', function (module, exports, __dirname, __filename) {
    var PASSTHROUGHS = [
        'getSource',
        'getTokens',
        'getComments',
        'getAllComments',
        'getAncestors',
        'getScope'
      ];
    function RuleContext(ruleId, eslint, options) {
      Object.defineProperty(this, 'id', { value: ruleId });
      Object.defineProperty(this, 'options', { value: options });
      PASSTHROUGHS.forEach(function (name) {
        this[name] = function () {
          return eslint[name].apply(eslint, arguments);
        };
      }, this);
      this.report = function (node, message, opts) {
        eslint.report(ruleId, node, message, opts);
      };
    }
    RuleContext.prototype = { constructor: RuleContext };
    module.exports = RuleContext;
  });
  require.define('/lib/util.js', function (module, exports, __dirname, __filename) {
    exports.mixin = function (target, source) {
      Object.keys(source).forEach(function (key) {
        target[key] = source[key];
      });
    };
    exports.mergeConfigs = function mergeConfigs(base, custom) {
      Object.keys(custom).forEach(function (key) {
        var property = custom[key];
        if (typeof property === 'object' && !Array.isArray(property)) {
          base[key] = mergeConfigs(base[key] || {}, custom[key]);
        } else {
          base[key] = custom[key];
        }
      });
      return base;
    };
  });
  require.define('/lib/rules.js', function (module, exports, __dirname, __filename) {
    var rules = Object.create(null), loadRules = require('/lib/load-rules.js', module);
    function define(ruleId, ruleModule) {
      rules[ruleId] = ruleModule;
    }
    function load(rulesDir) {
      var newRules = loadRules(rulesDir);
      Object.keys(newRules).forEach(function (ruleId) {
        define(ruleId, newRules[ruleId]);
      });
    }
    exports.load = load;
    exports.get = function (ruleId) {
      return rules[ruleId];
    };
    exports.define = define;
    load();
  });
  require.define('/lib/load-rules.js', function (module, exports, __dirname, __filename) {
    module.exports = function () {
      var rules = Object.create(null);
      rules['block-scoped-var'] = require('/lib/rules/block-scoped-var.js', module);
      rules['brace-style'] = require('/lib/rules/brace-style.js', module);
      rules['camelcase'] = require('/lib/rules/camelcase.js', module);
      rules['complexity'] = require('/lib/rules/complexity.js', module);
      rules['consistent-this'] = require('/lib/rules/consistent-this.js', module);
      rules['curly'] = require('/lib/rules/curly.js', module);
      rules['dot-notation'] = require('/lib/rules/dot-notation.js', module);
      rules['eqeqeq'] = require('/lib/rules/eqeqeq.js', module);
      rules['guard-for-in'] = require('/lib/rules/guard-for-in.js', module);
      rules['max-depth'] = require('/lib/rules/max-depth.js', module);
      rules['max-len'] = require('/lib/rules/max-len.js', module);
      rules['max-params'] = require('/lib/rules/max-params.js', module);
      rules['max-statements'] = require('/lib/rules/max-statements.js', module);
      rules['new-cap'] = require('/lib/rules/new-cap.js', module);
      rules['new-parens'] = require('/lib/rules/new-parens.js', module);
      rules['no-alert'] = require('/lib/rules/no-alert.js', module);
      rules['no-bitwise'] = require('/lib/rules/no-bitwise.js', module);
      rules['no-caller'] = require('/lib/rules/no-caller.js', module);
      rules['no-catch-shadow'] = require('/lib/rules/no-catch-shadow.js', module);
      rules['no-comma-dangle'] = require('/lib/rules/no-comma-dangle.js', module);
      rules['no-cond-assign'] = require('/lib/rules/no-cond-assign.js', module);
      rules['no-console'] = require('/lib/rules/no-console.js', module);
      rules['no-control-regex'] = require('/lib/rules/no-control-regex.js', module);
      rules['no-debugger'] = require('/lib/rules/no-debugger.js', module);
      rules['no-delete-var'] = require('/lib/rules/no-delete-var.js', module);
      rules['no-div-regex'] = require('/lib/rules/no-div-regex.js', module);
      rules['no-dupe-keys'] = require('/lib/rules/no-dupe-keys.js', module);
      rules['no-else-return'] = require('/lib/rules/no-else-return.js', module);
      rules['no-empty-class'] = require('/lib/rules/no-empty-class.js', module);
      rules['no-empty-label'] = require('/lib/rules/no-empty-label.js', module);
      rules['no-empty'] = require('/lib/rules/no-empty.js', module);
      rules['no-eq-null'] = require('/lib/rules/no-eq-null.js', module);
      rules['no-eval'] = require('/lib/rules/no-eval.js', module);
      rules['no-ex-assign'] = require('/lib/rules/no-ex-assign.js', module);
      rules['no-extra-semi'] = require('/lib/rules/no-extra-semi.js', module);
      rules['no-fallthrough'] = require('/lib/rules/no-fallthrough.js', module);
      rules['no-floating-decimal'] = require('/lib/rules/no-floating-decimal.js', module);
      rules['no-func-assign'] = require('/lib/rules/no-func-assign.js', module);
      rules['no-global-strict'] = require('/lib/rules/no-global-strict.js', module);
      rules['no-implied-eval'] = require('/lib/rules/no-implied-eval.js', module);
      rules['no-iterator'] = require('/lib/rules/no-iterator.js', module);
      rules['no-label-var'] = require('/lib/rules/no-label-var.js', module);
      rules['no-loop-func'] = require('/lib/rules/no-loop-func.js', module);
      rules['no-multi-str'] = require('/lib/rules/no-multi-str.js', module);
      rules['no-native-reassign'] = require('/lib/rules/no-native-reassign.js', module);
      rules['no-negated-in-lhs'] = require('/lib/rules/no-negated-in-lhs.js', module);
      rules['no-new-array'] = require('/lib/rules/no-new-array.js', module);
      rules['no-new-func'] = require('/lib/rules/no-new-func.js', module);
      rules['no-new-object'] = require('/lib/rules/no-new-object.js', module);
      rules['no-new-wrappers'] = require('/lib/rules/no-new-wrappers.js', module);
      rules['no-new'] = require('/lib/rules/no-new.js', module);
      rules['no-obj-calls'] = require('/lib/rules/no-obj-calls.js', module);
      rules['no-octal-escape'] = require('/lib/rules/no-octal-escape.js', module);
      rules['no-octal'] = require('/lib/rules/no-octal.js', module);
      rules['no-plusplus'] = require('/lib/rules/no-plusplus.js', module);
      rules['no-proto'] = require('/lib/rules/no-proto.js', module);
      rules['no-redeclare'] = require('/lib/rules/no-redeclare.js', module);
      rules['no-return-assign'] = require('/lib/rules/no-return-assign.js', module);
      rules['no-script-url'] = require('/lib/rules/no-script-url.js', module);
      rules['no-self-compare'] = require('/lib/rules/no-self-compare.js', module);
      rules['no-shadow'] = require('/lib/rules/no-shadow.js', module);
      rules['no-spaced-func'] = require('/lib/rules/no-spaced-func.js', module);
      rules['no-sync'] = require('/lib/rules/no-sync.js', module);
      rules['no-ternary'] = require('/lib/rules/no-ternary.js', module);
      rules['no-undef-init'] = require('/lib/rules/no-undef-init.js', module);
      rules['no-undef'] = require('/lib/rules/no-undef.js', module);
      rules['no-underscore-dangle'] = require('/lib/rules/no-underscore-dangle.js', module);
      rules['no-unreachable'] = require('/lib/rules/no-unreachable.js', module);
      rules['no-unused-expressions'] = require('/lib/rules/no-unused-expressions.js', module);
      rules['no-unused-vars'] = require('/lib/rules/no-unused-vars.js', module);
      rules['no-use-before-define'] = require('/lib/rules/no-use-before-define.js', module);
      rules['no-with'] = require('/lib/rules/no-with.js', module);
      rules['no-wrap-func'] = require('/lib/rules/no-wrap-func.js', module);
      rules['one-var'] = require('/lib/rules/one-var.js', module);
      rules['quote-props'] = require('/lib/rules/quote-props.js', module);
      rules['quotes'] = require('/lib/rules/quotes.js', module);
      rules['radix'] = require('/lib/rules/radix.js', module);
      rules['regex-spaces'] = require('/lib/rules/regex-spaces.js', module);
      rules['semi'] = require('/lib/rules/semi.js', module);
      rules['strict'] = require('/lib/rules/strict.js', module);
      rules['unnecessary-strict'] = require('/lib/rules/unnecessary-strict.js', module);
      rules['use-isnan'] = require('/lib/rules/use-isnan.js', module);
      rules['wrap-iife'] = require('/lib/rules/wrap-iife.js', module);
      rules['wrap-regex'] = require('/lib/rules/wrap-regex.js', module);
      return rules;
    };
  });
  require.define('/lib/rules/wrap-regex.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Literal': function (node) {
          var token = context.getTokens(node)[0], nodeType = token.type, source, grandparent, ancestors;
          if (nodeType === 'RegularExpression') {
            source = context.getTokens(node, 1, 1)[0].value;
            ancestors = context.getAncestors();
            grandparent = ancestors[ancestors.length - 1];
            if (grandparent.type === 'MemberExpression' && source[0] !== '(' && source[source.len - 1] !== ')') {
              context.report(node, 'Wrap the /regexp/ literal in parens to disambiguate the slash operator.');
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/wrap-iife.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'CallExpression': function (node) {
          if (node.callee.type === 'FunctionExpression') {
            var tokens = context.getTokens(node.callee, 1, 1);
            if (tokens[0].value !== '(' && tokens[tokens.length - 1].value !== ')') {
              context.report(node, 'Wrap an immediate function invocation in parentheses.');
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/use-isnan.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'BinaryExpression': function (node) {
          if (!/^[|&^]$/.test(node.operator) && node.left.name === 'NaN' || node.right.name === 'NaN') {
            context.report(node, 'Use the isNaN function to compare with NaN.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/unnecessary-strict.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Literal': function (node) {
          if (node.value === 'use strict') {
            var scope = context.getScope();
            if (scope.upper && scope.upper.isStrict) {
              context.report(node, "Unnecessary 'use strict'.");
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/strict.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var scopes = [];
      function enterScope() {
        scopes.push(scopes[scopes.length - 1] || false);
      }
      function exitScope(node) {
        var isStrict = scopes.pop();
        if (!isStrict && node.type !== 'Program') {
          context.report(node, 'Missing "use strict" statement.');
        }
      }
      return {
        'Program': enterScope,
        'FunctionDeclaration': enterScope,
        'FunctionExpression': enterScope,
        'Program:after': exitScope,
        'FunctionDeclaration:after': exitScope,
        'FunctionExpression:after': exitScope,
        'ExpressionStatement': function (node) {
          if (node.expression.value === 'use strict') {
            scopes[scopes.length] = true;
          }
        }
      };
    };
  });
  require.define('/lib/rules/semi.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function checkTokenForSemicolon(node, token) {
        if (token.type !== 'Punctuator' || token.value !== ';') {
          context.report(node, 'Missing semicolon.');
        }
      }
      function checkForSemicolon(node) {
        var tokens = context.getTokens(node), nextToken = tokens.pop();
        checkTokenForSemicolon(node, nextToken);
      }
      function checkForSemicolonForVariableDeclaration(node) {
        var ancestors = context.getAncestors(), parentIndex = ancestors.length - 1, parent = ancestors[parentIndex];
        if ((parent.type !== 'ForStatement' || parent.init !== node) && (parent.type !== 'ForInStatement' || parent.left !== node)) {
          checkForSemicolon(node);
        }
      }
      return {
        'VariableDeclaration': checkForSemicolonForVariableDeclaration,
        'ExpressionStatement': checkForSemicolon
      };
    };
  });
  require.define('/lib/rules/regex-spaces.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Literal': function (node) {
          var token = context.getTokens(node)[0], nodeType = token.type, nodeValue = token.value, multipleSpacesRegex = /( {2,})+?/, regexResults;
          if (nodeType === 'RegularExpression') {
            regexResults = multipleSpacesRegex.exec(nodeValue);
            if (regexResults !== null) {
              context.report(node, 'Spaces are hard to count. Use {' + regexResults[0].length + '}.');
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/radix.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'CallExpression': function (node) {
          if (node.callee.name === 'parseInt' && node.arguments.length === 1) {
            context.report(node, 'Missing radix parameter.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/quotes.js', function (module, exports, __dirname, __filename) {
    var DOUBLE_QUOTES = 'double', SINGLE_QUOTES = 'single';
    module.exports = function (context) {
      'use strict';
      function validDoubleQuotes(val) {
        return val[0] === '"' && val[val.length - 1] === '"';
      }
      function validSingleQuotes(val) {
        return val[0] === "'" && val[val.length - 1] === "'";
      }
      return {
        'Literal': function (node) {
          var val = node.value, rawVal = node.raw, quoteOptions = context.options[0];
          if (typeof val === 'string') {
            switch (quoteOptions) {
            case DOUBLE_QUOTES:
              if (!validDoubleQuotes(rawVal)) {
                context.report(node, 'Strings must use doublequote.');
              }
              break;
            case SINGLE_QUOTES:
              if (!validSingleQuotes(rawVal)) {
                context.report(node, 'Strings must use singlequote.');
              }
              break;
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/quote-props.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Property': function (node) {
          var key = node.key;
          if (key.type !== 'Literal') {
            context.report(node, 'Non-quoted property `{{key}}` found.', { key: key.name });
          }
        }
      };
    };
  });
  require.define('/lib/rules/one-var.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var functionStack = [];
      function startFunction() {
        functionStack.push(false);
      }
      function endFunction() {
        functionStack.pop();
      }
      function checkDeclarations(node) {
        if (functionStack[functionStack.length - 1]) {
          context.report(node, "Combine this with the previous 'var' statement.");
        } else {
          functionStack[functionStack.length - 1] = true;
        }
      }
      return {
        'Program': startFunction,
        'FunctionDeclaration': startFunction,
        'FunctionExpression': startFunction,
        'VariableDeclaration': checkDeclarations,
        'Program:after': endFunction,
        'FunctionDeclaration:after': endFunction,
        'FunctionExpression:after': endFunction
      };
    };
  });
  require.define('/lib/rules/no-wrap-func.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'FunctionExpression': function (node) {
          var ancestors = context.getAncestors();
          if (ancestors.pop().type !== 'CallExpression') {
            var tokens = context.getTokens(node, 1, 1);
            if (tokens[0].value === '(' && tokens[tokens.length - 1].value === ')') {
              context.report(node, 'Wrapping non-IIFE function literals in parens is unnecessary.');
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-with.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'WithStatement': function (node) {
          context.report(node, "Unexpected use of 'with' statement.");
        }
      };
    };
  });
  require.define('/lib/rules/no-use-before-define.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var findDeclaration = function (name, scope) {
        for (var i = 0, l = scope.variables.length; i < l; i++) {
          if (scope.variables[i].name === name) {
            return scope.variables[i];
          }
        }
        if (scope.upper) {
          return findDeclaration(name, scope.upper);
        }
      };
      var findVariables = function () {
        var scope = context.getScope();
        var checkLocationAndReport = function (reference, declaration) {
          if (declaration.identifiers[0].range[1] > reference.identifier.range[1]) {
            context.report(reference.identifier, '{{a}} was used before it was defined', { a: reference.identifier.name });
          }
        };
        scope.references.forEach(function (reference) {
          if (reference.identifier) {
            if (reference.resolved && reference.resolved.identifiers.length > 0) {
              checkLocationAndReport(reference, reference.resolved);
            } else {
              var declaration = findDeclaration(reference.identifier.name, scope);
              if (declaration && declaration.identifiers.length !== 0) {
                checkLocationAndReport(reference, declaration);
              }
            }
          }
        });
      };
      return {
        'Program': findVariables,
        'FunctionExpression': findVariables,
        'FunctionDeclaration': findVariables
      };
    };
  });
  require.define('/lib/rules/no-unused-vars.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var variables = [];
      var populateVariables = function () {
        var scope = context.getScope();
        scope.variables.forEach(function (variable) {
          if (variable.identifiers.length > 0) {
            if (!variables.some(function (storedVariable) {
                return storedVariable.name === variable.name && storedVariable.node === variable.identifiers[0];
              })) {
              variables.push({
                name: variable.name,
                node: variable.identifiers[0]
              });
            }
          }
        });
      };
      var findVariable = function (name) {
        var scope = context.getScope();
        var scopeVariable = [];
        var filter = function (variable) {
          return variable.name === name;
        };
        while (scopeVariable.length === 0) {
          scopeVariable = scope.variables.filter(filter);
          if (scopeVariable.length === 0) {
            if (!scope.upper) {
              return null;
            }
            scope = scope.upper;
          }
        }
        return variables.filter(function (variable) {
          return variable.name === scopeVariable[0].name && variable.node === scopeVariable[0].identifiers[0];
        })[0];
      };
      function isFunction(node) {
        return node && node.type && (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression');
      }
      function findFirstAncestorThatIsFunctionExpressionOrDeclaration(ancestors) {
        var currentAncestor;
        while (ancestors.length !== 0 && !isFunction(currentAncestor)) {
          currentAncestor = ancestors.pop();
        }
        return isFunction(currentAncestor) ? currentAncestor : undefined;
      }
      function markIgnorableUnusedVariables(usedVariable, ancestors) {
        var ancestorFunctionNode = findFirstAncestorThatIsFunctionExpressionOrDeclaration(ancestors);
        if (ancestorFunctionNode) {
          var fnParamNames = ancestorFunctionNode.params.map(function (param) {
              return param.name;
            });
          var variableIndex = fnParamNames.indexOf(usedVariable.name);
          if (variableIndex !== -1) {
            var ignorableVariables = fnParamNames.slice(0, variableIndex);
            ignorableVariables.forEach(function (ignorableVariable) {
              variables.forEach(function (variable) {
                if (variable.name === ignorableVariable) {
                  variable.ignorable = true;
                }
              });
            });
          }
        }
      }
      return {
        'FunctionDeclaration': populateVariables,
        'FunctionExpression': populateVariables,
        'Program': populateVariables,
        'Identifier': function (node) {
          var ancestors = context.getAncestors(node);
          var parent = ancestors.pop();
          var grandparent = ancestors.pop();
          if ((parent.type !== 'AssignmentExpression' || node !== parent.left) && (parent.type !== 'VariableDeclarator' || parent.init && parent.init === node) && parent.type !== 'FunctionDeclaration' && (parent.type !== 'FunctionExpression' || grandparent !== null && grandparent.type === 'CallExpression')) {
            var variable = findVariable(node.name);
            if (variable) {
              variable.used = true;
              markIgnorableUnusedVariables(variable, ancestors);
            }
          }
        },
        'Program:after': function () {
          var unused = variables.filter(function (variable) {
              return !variable.used && !variable.ignorable;
            });
          unused.forEach(function (variable) {
            context.report(variable.node, '{{var}} is defined but never used', { 'var': variable.name });
          });
        }
      };
    };
  });
  require.define('/lib/rules/no-unused-expressions.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function isPragma(expression, parent) {
        var isStrict = expression.type === 'Literal' && expression.value === 'use strict', isGlobalStrict = isStrict && (parent.type === 'Program' && parent.body[0].expression === expression), isLocalStrict = isStrict && (parent.type === 'BlockStatement' && parent.body[0].expression === expression);
        return isGlobalStrict || isLocalStrict;
      }
      return {
        'ExpressionStatement': function (node) {
          var type = node.expression.type, parent = context.getAncestors().pop();
          if (!/^(?:Assignment|Call|New|Update)Expression$/.test(type) && ('UnaryExpression' !== type || 'delete' !== node.expression.operator) && !isPragma(node.expression, parent)) {
            context.report(node, 'Expected an assignment or function call and instead saw an expression.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-unreachable.js', function (module, exports, __dirname, __filename) {
    function report(context, node, unreachableType) {
      context.report(node, 'Found unexpected statement after a {{type}}.', { type: unreachableType });
    }
    module.exports = function (context) {
      'use strict';
      function checkForUnreachable(node) {
        switch (node.type) {
        case 'ReturnStatement':
          return 'return';
        case 'ThrowStatement':
          return 'throw';
        case 'ContinueStatement':
          return 'continue';
        case 'BreakStatement':
          return 'break';
        default:
          return false;
        }
      }
      return {
        'BlockStatement': function (node) {
          var i, unreachableType = false;
          for (i = 1; i < node.body.length; i++) {
            unreachableType = unreachableType || checkForUnreachable(node.body[i - 1]);
            if (unreachableType) {
              report(context, node.body[i], unreachableType);
            }
          }
        },
        'SwitchCase': function (node) {
          var i, unreachableType = false;
          for (i = 1; i < node.consequent.length; i++) {
            unreachableType = unreachableType || checkForUnreachable(node.consequent[i - 1]);
            if (unreachableType) {
              report(context, node.consequent[i], unreachableType);
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-underscore-dangle.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function hasTrailingUnderscore(identifier) {
        var len = identifier.length;
        return identifier !== '_' && (identifier[0] === '_' || identifier[len - 1] === '_');
      }
      function isSpecialCaseIdentifierForMemberExpression(identifier) {
        return identifier === '__proto__';
      }
      function isSpecialCaseIdentifierInVariableExpression(identifier) {
        return identifier === '_';
      }
      function checkForTrailingUnderscoreInFunctionDeclaration(node) {
        var identifier = node.id.name;
        if (typeof identifier !== 'undefined' && hasTrailingUnderscore(identifier)) {
          context.report(node, "Unexpected dangling '_' in '" + identifier + "'.");
        }
      }
      function checkForTrailingUnderscoreInVariableExpression(node) {
        var identifier = node.id.name;
        if (typeof identifier !== 'undefined' && hasTrailingUnderscore(identifier) && !isSpecialCaseIdentifierInVariableExpression(identifier)) {
          context.report(node, "Unexpected dangling '_' in '" + identifier + "'.");
        }
      }
      function checkForTrailingUnderscoreInMemberExpression(node) {
        var identifier = node.property.name;
        if (typeof identifier !== 'undefined' && hasTrailingUnderscore(identifier) && !isSpecialCaseIdentifierForMemberExpression(identifier)) {
          context.report(node, "Unexpected dangling '_' in '" + identifier + "'.");
        }
      }
      return {
        'FunctionDeclaration': checkForTrailingUnderscoreInFunctionDeclaration,
        'VariableDeclarator': checkForTrailingUnderscoreInVariableExpression,
        'MemberExpression': checkForTrailingUnderscoreInMemberExpression
      };
    };
  });
  require.define('/lib/rules/no-undef.js', function (module, exports, __dirname, __filename) {
    function isImplicitGlobal(variable) {
      return variable.defs.every(function (def) {
        return def.type === 'ImplicitGlobalVariable';
      });
    }
    function getDeclaredGlobalVariable(scope, ref) {
      var declaredGlobal = null;
      scope.variables.some(function (variable) {
        if (variable.name === ref.identifier.name) {
          if (!isImplicitGlobal(variable) || Object.hasOwnProperty.call(variable, 'writeable')) {
            declaredGlobal = variable;
            return true;
          }
        }
        return false;
      });
      return declaredGlobal;
    }
    module.exports = function (context) {
      'use strict';
      return {
        'Program': function () {
          var globalScope = context.getScope();
          globalScope.through.forEach(function (ref) {
            var variable = getDeclaredGlobalVariable(globalScope, ref), name = ref.identifier.name;
            if (!variable) {
              context.report(ref.identifier, "'{{name}}' is not defined.", { name: name });
            } else if (ref.isWrite() && variable.writeable === false) {
              context.report(ref.identifier, "'{{name}}' is read only.", { name: name });
            }
          });
        }
      };
    };
  });
  require.define('/lib/rules/no-undef-init.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'VariableDeclarator': function (node) {
          var name = node.id.name;
          var init = node.init && node.init.name;
          if (init === 'undefined') {
            context.report(node, "It's not necessary to initialize '{{name}}' to undefined.", { name: name });
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-ternary.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'ConditionalExpression': function (node) {
          context.report(node, 'Ternary operator used.');
        }
      };
    };
  });
  require.define('/lib/rules/no-sync.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'MemberExpression': function (node) {
          var propertyName = node.property.name, syncRegex = /.*Sync$/;
          if (syncRegex.exec(propertyName) !== null) {
            context.report(node, "Unexpected sync method: '" + propertyName + "'.");
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-spaced-func.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function findOpenParen(tokens) {
        var openParenIndices = [];
        tokens.forEach(function (token, i) {
          if (token.value === '(') {
            openParenIndices.push(i);
          }
        });
        return openParenIndices;
      }
      function detectOpenSpaces(node) {
        var tokens = context.getTokens(node), openParenIndices = findOpenParen(tokens), prevToken, curToken, isSpaceBetweenRange, isPrevTokenValid;
        openParenIndices.forEach(function (i) {
          prevToken = tokens[i - 1];
          curToken = tokens[i];
          if (!prevToken) {
            return;
          }
          isSpaceBetweenRange = prevToken.range[1] !== curToken.range[0];
          isPrevTokenValid = prevToken.value !== '(';
          if (isSpaceBetweenRange && isPrevTokenValid) {
            context.report(node, 'Spaced function application is not allowed.');
          }
        });
      }
      return {
        'CallExpression': detectOpenSpaces,
        'NewExpression': detectOpenSpaces
      };
    };
  });
  require.define('/lib/rules/no-shadow.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var checkForShadows = function (node) {
        var scope = context.getScope();
        var args = node.params;
        var variables = scope.variables.filter(function (item) {
            return !args.some(function (variable) {
              return variable.name === item.name;
            });
          });
        var upper = scope.upper;
        var findDups = function (variables) {
          variables.forEach(function (variable) {
            if (upper.variables.some(function (scopeVar) {
                if (scopeVar.identifiers.length > 0) {
                  return scopeVar.name === variable.name;
                }
                return false;
              })) {
              context.report(variable.identifiers[0], '{{a}} is already declared in the upper scope.', { a: variable.name });
            }
          });
        };
        while (upper) {
          findDups(variables);
          upper = upper.upper;
        }
      };
      return {
        'FunctionDeclaration': checkForShadows,
        'FunctionExpression': checkForShadows
      };
    };
  });
  require.define('/lib/rules/no-self-compare.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'BinaryExpression': function (node) {
          var operators = [
              '===',
              '==',
              '!==',
              '!=',
              '>',
              '<',
              '>=',
              '<='
            ];
          if (operators.indexOf(node.operator) > -1 && (node.left.type === 'Identifier' && node.right.type === 'Identifier' && node.left.name === node.right.name || node.left.type === 'Literal' && node.right.type === 'Literal' && node.left.value === node.right.value)) {
            context.report(node, 'Comparing to itself is potentially pointless.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-script-url.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Literal': function (node) {
          if (node.value && typeof node.value === 'string' && node.value.toLowerCase().indexOf('javascript:') >= 0) {
            context.report(node, 'Script URL is a form of eval.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-return-assign.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'ReturnStatement': function (node) {
          if (node.argument && node.argument.type === 'AssignmentExpression') {
            context.report(node, 'Return statement should not contain assigment.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-redeclare.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var findVariables = function () {
        var scope = context.getScope();
        scope.variables.forEach(function (variable) {
          if (variable.identifiers && variable.identifiers.length > 1) {
            variable.identifiers.sort(function (a, b) {
              return b.range[1] - a.range[1];
            });
            for (var i = 1, l = variable.identifiers.length; i < l; i++) {
              context.report(variable.identifiers[i], '{{a}} is already defined', { a: variable.name });
            }
          }
        });
      };
      return {
        'Program': findVariables,
        'FunctionExpression': findVariables,
        'FunctionDeclaration': findVariables
      };
    };
  });
  require.define('/lib/rules/no-proto.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'MemberExpression': function (node) {
          if (node.property && (node.property.type === 'Identifier' && node.property.name === '__proto__' && !node.computed) || node.property.type === 'Literal' && node.property.value === '__proto__') {
            context.report(node, "The '__proto__' property is deprecated.");
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-plusplus.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'UpdateExpression': function (node) {
          context.report(node, "Unary operator '" + node.operator + "' used.");
        }
      };
    };
  });
  require.define('/lib/rules/no-octal.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Literal': function (node) {
          if (typeof node.value === 'number' && /^0[0-7]/.test(node.raw)) {
            context.report(node, 'Octal literals should not be used.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-octal-escape.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Literal': function (node) {
          var match = node.raw.match(/^([^\\]|\\[^0-7])*\\([0-7])/), octalDigit;
          if (match) {
            octalDigit = match[2];
            context.report(node, "Don't use octal: '\\{{octalDigit}}'. Use '\\u....' instead.", { octalDigit: octalDigit });
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-obj-calls.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'CallExpression': function (node) {
          if (node.callee.type === 'Identifier') {
            var name = node.callee.name;
            if (name === 'Math' || name === 'JSON') {
              context.report(node, "'{{name}}' is not a function.", { name: name });
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-new.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'ExpressionStatement': function (node) {
          if (node.expression.type === 'NewExpression') {
            context.report(node, "Do not use 'new' for side effects.");
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-new-wrappers.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'NewExpression': function (node) {
          var wrapperObjects = [
              'String',
              'Number',
              'Boolean',
              'Math',
              'JSON'
            ];
          if (wrapperObjects.indexOf(node.callee.name) > -1) {
            context.report(node, 'Do not use {{fn}} as a constructor.', { fn: node.callee.name });
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-new-object.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'NewExpression': function (node) {
          if (node.callee.name === 'Object') {
            context.report(node, 'The object literal notation {} is preferrable.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-new-func.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'NewExpression': function (node) {
          if (node.callee.name === 'Function') {
            context.report(node, 'The Function constructor is eval.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-new-array.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'NewExpression': function (node) {
          if (node.callee.name === 'Array') {
            context.report(node, 'The array literal notation [] is preferrable.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-negated-in-lhs.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'BinaryExpression': function (node) {
          if (node.operator === 'in' && node.left.type === 'UnaryExpression' && node.left.operator === '!') {
            context.report(node, "The `in` expression's left operand is negated");
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-native-reassign.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var nativeObjects = [
          'Array',
          'Boolean',
          'Date',
          'decodeURI',
          'decodeURIComponent',
          'encodeURI',
          'encodeURIComponent',
          'Error',
          'eval',
          'EvalError',
          'Function',
          'isFinite',
          'isNaN',
          'JSON',
          'Math',
          'Number',
          'Object',
          'parseInt',
          'parseFloat',
          'RangeError',
          'ReferenceError',
          'RegExp',
          'String',
          'SyntaxError',
          'TypeError',
          'URIError',
          'Map',
          'NaN',
          'Set',
          'WeakMap',
          'Infinity',
          'undefined'
        ];
      return {
        'AssignmentExpression': function (node) {
          if (nativeObjects.indexOf(node.left.name) >= 0) {
            context.report(node, node.left.name + ' is a read-only native object.');
          }
        },
        'VariableDeclarator': function (node) {
          if (nativeObjects.indexOf(node.id.name) >= 0) {
            context.report(node, "Redefinition of '{{nativeObject}}'.", { nativeObject: node.id.name });
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-multi-str.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Literal': function (node) {
          var lineBreak = /\n/;
          if (lineBreak.test(node.raw)) {
            context.report(node, 'Multiline support is limited to browsers supporting ES5 only.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-loop-func.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var checkForLoops = function (node) {
        var ancestors = context.getAncestors();
        if (ancestors.some(function (ancestor) {
            return ancestor.type === 'ForStatement' || ancestor.type === 'WhileStatement' || ancestor.type === 'DoWhileStatement';
          })) {
          context.report(node, "Don't make functions within a loop");
        }
      };
      return {
        'FunctionExpression': checkForLoops,
        'FunctionDeclaration': checkForLoops
      };
    };
  });
  require.define('/lib/rules/no-label-var.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function findIdentifier(scope, identifier) {
        var found = false;
        scope.variables.forEach(function (variable) {
          if (variable.name === identifier) {
            found = true;
          }
        });
        scope.references.forEach(function (reference) {
          if (reference.identifier.name === identifier) {
            found = true;
          }
        });
        if (scope.upper && !found) {
          return findIdentifier(scope.upper, identifier);
        }
        return found;
      }
      return {
        'LabeledStatement': function (node) {
          var scope = context.getScope();
          if (findIdentifier(scope, node.label.name)) {
            context.report(node, 'Found identifier with same name as label.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-iterator.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'MemberExpression': function (node) {
          if (node.property && (node.property.type === 'Identifier' && node.property.name === '__iterator__' && !node.computed) || node.property.type === 'Literal' && node.property.value === '__iterator__') {
            context.report(node, "Reserved name '__iterator__'.");
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-implied-eval.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'CallExpression': function (node) {
          if (node.callee.type === 'Identifier') {
            var callee = node.callee.name;
            if (callee === 'setTimeout' || callee === 'setInterval') {
              var argument = node.arguments[0];
              if (argument && argument.type === 'Literal' && typeof argument.value === 'string') {
                context.report(node, 'Implied eval. Consider passing a function instead of a string.');
              }
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-global-strict.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'ExpressionStatement': function (node) {
          var parent = context.getAncestors().pop();
          if (node.expression.value === 'use strict' && parent.type === 'Program') {
            context.report(node, 'Use the function form of "use strict".');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-func-assign.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function checkIfIdentifierIsFunction(scope, name) {
        var variable, def, i, j;
        for (i = 0; i < scope.variables.length; i++) {
          variable = scope.variables[i];
          for (j = 0; j < variable.defs.length; j++) {
            def = variable.defs[j];
            if (def.name.name === name && def.type === 'FunctionName') {
              return true;
            }
            if (def.name.name === name) {
              return false;
            }
          }
        }
        if (scope.upper) {
          return checkIfIdentifierIsFunction(scope.upper, name);
        }
        return false;
      }
      return {
        'AssignmentExpression': function (node) {
          var scope = context.getScope(), name = node.left.name;
          if (checkIfIdentifierIsFunction(scope, name)) {
            context.report(node, "'{{name}}' is a function.", { name: name });
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-floating-decimal.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Literal': function (node) {
          if (typeof node.value === 'number') {
            if (node.raw.indexOf('.') === 0) {
              context.report(node, 'A leading decimal point can be confused with a dot.');
            }
            if (node.raw.indexOf('.') === node.raw.length - 1) {
              context.report(node, 'A trailing decimal point can be confused with a dot.');
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-fallthrough.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'SwitchStatement': function (node) {
          var cases = node.cases, ft = /\s*\/\*\s*falls\sthrough\s*\*\/\s*/, consequent, i, len, switchCase;
          if (typeof cases !== 'undefined') {
            for (i = 0, len = cases.length; i < len; i++) {
              switchCase = cases[i];
              consequent = switchCase.consequent;
              if (consequent.length !== 0) {
                var finalConsequentStatement = consequent[consequent.length - 1], isBreakStatement = finalConsequentStatement.type === 'BreakStatement', isReturnStatement = finalConsequentStatement.type === 'ReturnStatement', isThrowStatement = finalConsequentStatement.type === 'ThrowStatement', hasFallThroughComment = ft.exec(context.getSource(finalConsequentStatement, 0, 20)) !== null;
                if (!isBreakStatement && !isReturnStatement && !isThrowStatement && !hasFallThroughComment) {
                  context.report(node, 'No fall-through without explicit comment.');
                }
              }
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-extra-semi.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'EmptyStatement': function (node) {
          context.report(node, 'Unnecessary semicolon.');
        }
      };
    };
  });
  require.define('/lib/rules/no-ex-assign.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var inCatch = false, exceptionName = null;
      return {
        'CatchClause': function (node) {
          inCatch = true;
          exceptionName = node.param.name;
        },
        'CatchClause:after': function () {
          inCatch = false;
          exceptionName = null;
        },
        'AssignmentExpression': function (node) {
          if (inCatch) {
            if (node.left.name === exceptionName) {
              context.report(node, 'Do not assign to the exception parameter.');
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-eval.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'CallExpression': function (node) {
          if (node.callee.name === 'eval') {
            context.report(node, 'eval can be harmful.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-eq-null.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'BinaryExpression': function (node) {
          var badOperator = node.operator === '==' || node.operator === '!=';
          if (node.right.type === 'Literal' && node.right.raw === 'null' && badOperator || node.left.type === 'Literal' && node.left.raw === 'null' && badOperator) {
            context.report(node, 'Use \u2018===\u2019 to compare with \u2018null\u2019.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-empty.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'BlockStatement': function (node) {
          var ancestors = context.getAncestors(), parentType = ancestors[ancestors.length - 1].type;
          if (parentType === 'FunctionExpression' || parentType === 'FunctionDeclaration') {
            return;
          }
          if (node.body.length === 0) {
            context.report(node, 'Empty block statement.');
          }
        },
        'SwitchStatement': function (node) {
          if (typeof node.cases === 'undefined' || node.cases.length === 0) {
            context.report(node, 'Empty switch statement.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-empty-label.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'LabeledStatement': function (node) {
          if (node.body.type !== 'ForStatement' && node.body.type !== 'WhileStatement' && node.body.type !== 'DoWhileStatement' && node.body.type !== 'SwitchStatement') {
            context.report(node, 'Unexpected label {{l}}', { l: node.label.name });
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-empty-class.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Literal': function (node) {
          var tokens = context.getTokens(node);
          tokens.forEach(function (token) {
            if (token.type === 'RegularExpression' && !/^\/([^\\[]|\\.|\[([^\\\]]|\\.)+\])*\/[gimy]*$/.test(token.value)) {
              context.report(node, 'Empty class.');
            }
          });
        }
      };
    };
  });
  require.define('/lib/rules/no-else-return.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function checkForReturnStatement(node, alternate) {
        if (node.type === 'ReturnStatement') {
          context.report(alternate, "Unexpected 'else' after 'return'\u200b.");
        }
      }
      return {
        'IfStatement': function (node) {
          if (node.alternate && node.consequent) {
            if (node.consequent.type === 'BlockStatement') {
              node.consequent.body.forEach(function (bodyNode) {
                checkForReturnStatement(bodyNode, node.alternate);
              });
            } else {
              checkForReturnStatement(node.consequent, node.alternate);
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-dupe-keys.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'ObjectExpression': function (node) {
          var nodeProps = {};
          node.properties.forEach(function (property) {
            var safeKey = '$-' + (property.key.name || property.key.value);
            if (nodeProps[safeKey]) {
              context.report(node, "Duplicate key '{{key}}'.", { key: safeKey.split('-')[1] });
            } else {
              nodeProps[safeKey] = true;
            }
          });
        }
      };
    };
  });
  require.define('/lib/rules/no-div-regex.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Literal': function (node) {
          var token = context.getTokens(node)[0], nodeType = token.type, source;
          if (nodeType === 'RegularExpression') {
            source = context.getTokens(node, 1, 1)[0].value;
            if (source[1] === '=') {
              context.report(node, "A regular expression literal can be confused with '/='.");
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-delete-var.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'UnaryExpression': function (node) {
          if (node.operator === 'delete' && node.argument.type === 'Identifier') {
            context.report(node, 'Variables should not be deleted\u200b.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-debugger.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'DebuggerStatement': function (node) {
          context.report(node, "Unexpected 'debugger' statement.");
        }
      };
    };
  });
  require.define('/lib/rules/no-control-regex.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function getRegExp(node) {
        if (node.value instanceof RegExp) {
          return node.value;
        } else if (typeof node.value === 'string') {
          var parent = context.getAncestors().pop();
          if ((parent.type === 'NewExpression' || parent.type === 'CallExpression') && parent.callee.type === 'Identifier' && parent.callee.name === 'RegExp') {
            try {
              return new RegExp(node.value);
            } catch (ex) {
              return null;
            }
          }
        } else {
          return null;
        }
      }
      return {
        'Literal': function (node) {
          var computedValue, regex = getRegExp(node);
          if (regex) {
            computedValue = regex.toString();
            if (/[\x00-\x1f]/.test(computedValue)) {
              context.report(node, 'Unexpected control character in regular expression.');
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-console.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'MemberExpression': function (node) {
          if (node.object.name === 'console') {
            context.report(node, 'Unexpected console statement.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-cond-assign.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var message = 'Expected a conditional expression and instead saw an assignment.', targetExpr = 'AssignmentExpression';
      function testForAssign(node) {
        var type = node.test.type;
        if (type === targetExpr) {
          context.report(node, message);
        }
      }
      return {
        'IfStatement': testForAssign,
        'WhileStatement': testForAssign,
        'DoWhileStatement': testForAssign,
        'ForStatement': testForAssign
      };
    };
  });
  require.define('/lib/rules/no-comma-dangle.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function checkForTrailingComma(node) {
        var tokens = context.getTokens(node), secondToLastToken = tokens[tokens.length - 2];
        if (secondToLastToken.value === ',') {
          context.report(node, 'Trailing comma.');
        }
      }
      return {
        'ObjectExpression': checkForTrailingComma,
        'ArrayExpression': checkForTrailingComma
      };
    };
  });
  require.define('/lib/rules/no-catch-shadow.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function paramIsShadowing(scope, name) {
        var found = scope.variables.some(function (variable) {
            return variable.name === name;
          });
        if (found) {
          return true;
        }
        if (scope.upper) {
          return paramIsShadowing(scope.upper, name);
        }
        return false;
      }
      return {
        'CatchClause': function (node) {
          var scope = context.getScope();
          if (paramIsShadowing(scope, node.param.name)) {
            context.report(node, "Value of '{{name}}' may be overwritten in IE 8 and earlier.", { name: node.param.name });
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-caller.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'MemberExpression': function (node) {
          var objectName = node.object.name, propertyName = node.property.name;
          if (objectName === 'arguments' && !node.computed && propertyName && propertyName.match(/^calle[er]$/)) {
            context.report(node, 'Avoid arguments.{{property}}.', { property: propertyName });
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-bitwise.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function report(node) {
        context.report(node, "Unexpected use of '{{operator}}'.", { operator: node.operator });
      }
      return {
        'BinaryExpression': function (node) {
          if (node.operator.match(/^(?:[\^&\|~]|<<|>>>?)$/)) {
            report(node);
          }
        },
        'UnaryExpression': function (node) {
          if (node.operator === '~') {
            report(node);
          }
        }
      };
    };
  });
  require.define('/lib/rules/no-alert.js', function (module, exports, __dirname, __filename) {
    function matchProhibited(name) {
      return name.match(/^(alert|confirm|prompt)$/);
    }
    function report(context, node, result) {
      context.report(node, 'Unexpected {{name}}.', { name: result[1] });
    }
    module.exports = function (context) {
      'use strict';
      return {
        'CallExpression': function (node) {
          var result;
          if (node.callee.type === 'Identifier') {
            result = matchProhibited(node.callee.name);
            if (result) {
              report(context, node, result);
            }
          } else if (node.callee.type === 'MemberExpression' && node.callee.property.type === 'Identifier') {
            result = matchProhibited(node.callee.property.name);
            if (result && node.callee.object.name === 'window') {
              report(context, node, result);
            }
          }
        }
      };
    };
  });
  require.define('/lib/rules/new-parens.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'NewExpression': function (node) {
          var tokens = context.getTokens(node);
          var prenticesTokens = tokens.filter(function (token) {
              return token.value === '(' || token.value === ')';
            });
          if (prenticesTokens.length < 2) {
            context.report(node, "Missing '()' invoking a constructor");
          }
        }
      };
    };
  });
  require.define('/lib/rules/new-cap.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'NewExpression': function (node) {
          var constructorName = '';
          if (node.callee.type === 'MemberExpression') {
            constructorName = node.callee.property.name;
          } else {
            constructorName = node.callee.name;
          }
          if (constructorName && constructorName.charAt(0) === constructorName.charAt(0).toLowerCase()) {
            context.report(node, 'A constructor name should start with an uppercase letter.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/max-statements.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var functionStack = [], maxStatements = context.options[0] || 10;
      function startFunction() {
        functionStack.push(0);
      }
      function endFunction(node) {
        var count = functionStack.pop();
        if (count > maxStatements) {
          context.report(node, 'This function has too many statements ({{count}}). Maximum allowed is {{max}}.', {
            count: count,
            max: maxStatements
          });
        }
      }
      function countStatements(node) {
        functionStack[functionStack.length - 1] += node.body.length;
      }
      return {
        'FunctionDeclaration': startFunction,
        'FunctionExpression': startFunction,
        'BlockStatement': countStatements,
        'FunctionDeclaration:after': endFunction,
        'FunctionExpression:after': endFunction
      };
    };
  });
  require.define('/lib/rules/max-params.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var numParams = context.options[0] || 3;
      return {
        'FunctionDeclaration': function (node) {
          if (node.params.length > numParams) {
            context.report(node, 'This function has too many parameters ({{count}}). Maximum allowed is {{max}}.', {
              count: node.params.length,
              max: numParams
            });
          }
        },
        'FunctionExpression': function (node) {
          if (node.params.length > numParams) {
            context.report(node, 'This function has too many parameters ({{count}}). Maximum allowed is {{max}}.', {
              count: node.params.length,
              max: numParams
            });
          }
        }
      };
    };
  });
  require.define('/lib/rules/max-len.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var tabWidth = context.options[1];
      function stringRepeat(num) {
        num = parseInt(num, 10);
        var str = '', i;
        for (i = 0; i < tabWidth; i += 1) {
          str += ' ';
        }
        return str;
      }
      var maxLength = context.options[0], tabString = stringRepeat(' ', tabWidth);
      function checkProgramForMaxLength(node) {
        node.range[0] = 0;
        var lines = context.getSource(node).split('\n'), i, line;
        for (i = 0; i < lines.length; i++) {
          line = lines[i];
          line = line.replace(/\t/g, tabString);
          if (line.length > maxLength) {
            context.report(node, 'Line ' + i + ' exceeds the maximum line length of ' + maxLength + '.');
          }
        }
      }
      return { 'Program': checkProgramForMaxLength };
    };
  });
  require.define('/lib/rules/max-depth.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var functionStack = [], maxDepth = context.options[0] || 4;
      function startFunction() {
        functionStack.push(0);
      }
      function endFunction() {
        functionStack.pop();
      }
      function pushBlock(node) {
        var len = ++functionStack[functionStack.length - 1];
        if (len > maxDepth) {
          context.report(node, 'Blocks are nested too deeply ({{depth}}).', { depth: len });
        }
      }
      function popBlock() {
        functionStack[functionStack.length - 1]--;
      }
      return {
        'Program': startFunction,
        'FunctionDeclaration': startFunction,
        'FunctionExpression': startFunction,
        'IfStatement': pushBlock,
        'SwitchStatement': pushBlock,
        'TryStatement': pushBlock,
        'DoWhileStatement': pushBlock,
        'WhileStatement': pushBlock,
        'WithStatement': pushBlock,
        'ForStatement': pushBlock,
        'ForInStatement': pushBlock,
        'IfStatement:after': popBlock,
        'SwitchStatement:after': popBlock,
        'TryStatement:after': popBlock,
        'DoWhileStatement:after': popBlock,
        'WhileStatement:after': popBlock,
        'WithStatement:after': popBlock,
        'ForStatement:after': popBlock,
        'ForInStatement:after': popBlock,
        'FunctionDeclaration:after': endFunction,
        'FunctionExpression:after': endFunction,
        'Program:after': endFunction
      };
    };
  });
  require.define('/lib/rules/guard-for-in.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'ForInStatement': function (node) {
          var body = node.body.type === 'BlockStatement' ? node.body.body[0] : node.body;
          if (body && body.type !== 'IfStatement') {
            context.report(node, 'The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype.');
          }
        }
      };
    };
  });
  require.define('/lib/rules/eqeqeq.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function isTypeOf(node) {
        return [
          node.left,
          node.right
        ].some(function (node) {
          return node.type === 'UnaryExpression' && node.operator === 'typeof';
        });
      }
      function bothAreSameTypeLiterals(node) {
        return node.left.type === 'Literal' && node.right.type === 'Literal' && typeof node.left.value === typeof node.right.value;
      }
      return {
        'BinaryExpression': function (node) {
          var operator = node.operator;
          if (context.options[0] === 'smart' && (isTypeOf(node) || bothAreSameTypeLiterals(node))) {
            return;
          }
          if (operator === '==') {
            context.report(node, "Expected '===' and instead saw '=='.");
          } else if (operator === '!=') {
            context.report(node, "Expected '!==' and instead saw '!='.");
          }
        }
      };
    };
  });
  require.define('/lib/rules/dot-notation.js', function (module, exports, __dirname, __filename) {
    var validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
    var keywords = [
        'this',
        'function',
        'if',
        'return',
        'var',
        'else',
        'for',
        'new',
        'arguments',
        'in',
        'typeof',
        'while',
        'case',
        'break',
        'try',
        'catch',
        'delete',
        'throw',
        'switch',
        'continue',
        'default',
        'instanceof',
        'do',
        'void',
        'finally',
        'with',
        'debugger',
        'eval',
        'implements',
        'interface',
        'package',
        'private',
        'protected',
        'public',
        'static',
        'yield',
        'let',
        'class',
        'enum',
        'export',
        'extends',
        'import',
        'super'
      ];
    function canBeWrittenInDotNotation(node) {
      return node.computed === true && node.property.type === 'Literal' && validIdentifier.test(node.property.value) && keywords.indexOf(node.property.value) === -1;
    }
    module.exports = function (context) {
      return {
        'MemberExpression': function (node) {
          if (canBeWrittenInDotNotation(node)) {
            context.report(node, "['" + node.property.value + "'] is better written in dot notation.");
          }
        }
      };
    };
  });
  require.define('/lib/rules/curly.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'IfStatement': function (node) {
          if (node.consequent.type !== 'BlockStatement') {
            context.report(node, "Expected { after 'if' condition.");
          }
          if (node.alternate && node.alternate.type !== 'BlockStatement' && node.alternate.type !== 'IfStatement') {
            context.report(node, "Expected { after 'else'.");
          }
        },
        'WhileStatement': function (node) {
          if (node.body.type !== 'BlockStatement') {
            context.report(node, "Expected { after 'while' condition.");
          }
        },
        'DoWhileStatement': function (node) {
          if (node.body.type !== 'BlockStatement') {
            context.report(node, "Expected { after 'do'.");
          }
        },
        'ForStatement': function (node) {
          if (node.body.type !== 'BlockStatement') {
            context.report(node, "Expected { after 'for' condition.");
          }
        }
      };
    };
  });
  require.define('/lib/rules/consistent-this.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      return {
        'VariableDeclaration': function (node) {
          var alias = context.options[0];
          node.declarations.forEach(function (declaration) {
            if (declaration.id.name === alias && !(declaration.init && declaration.init.type === 'ThisExpression')) {
              context.report(node, "Designated 'this' alias '{{alias}}' is not assigned " + 'to the current execution context.', { alias: declaration.id.name });
            }
            if (declaration.init && declaration.init.type === 'ThisExpression' && declaration.id.name !== alias) {
              context.report(node, "Unexpected alias '{{alias}}' for 'this'.", { alias: declaration.id.name });
            }
          });
        }
      };
    };
  });
  require.define('/lib/rules/complexity.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var THRESHOLD = context.options[0];
      var fns = [];
      function startFunction() {
        fns.push(1);
      }
      function endFunction(node) {
        var complexity = fns.pop(), name = 'anonymous';
        if (node.id) {
          name = node.id.name;
        }
        if (complexity > THRESHOLD) {
          context.report(node, "Function '{{name}}' has a complexity of {{complexity}}.", {
            name: name,
            complexity: complexity
          });
        }
      }
      function increaseComplexity() {
        if (fns.length) {
          fns[fns.length - 1]++;
        }
      }
      function increaseSwitchComplexity(node) {
        if (node.test) {
          increaseComplexity(node);
        }
      }
      function increaseLogicalComplexity(node) {
        if (node.operator === '||') {
          increaseComplexity(node);
        }
      }
      return {
        'FunctionDeclaration': startFunction,
        'FunctionExpression': startFunction,
        'FunctionDeclaration:after': endFunction,
        'FunctionExpression:after': endFunction,
        'CatchClause': increaseComplexity,
        'ConditionalExpression': increaseComplexity,
        'LogicalExpression': increaseLogicalComplexity,
        'ForStatement': increaseComplexity,
        'ForInStatement': increaseComplexity,
        'IfStatement': increaseComplexity,
        'SwitchCase': increaseSwitchComplexity,
        'WhileStatement': increaseComplexity,
        'DoWhileStatement': increaseComplexity
      };
    };
  });
  require.define('/lib/rules/camelcase.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      return {
        'Identifier': function (node) {
          var name = node.name.replace(/^_+|_+$/g, '');
          if (name.indexOf('_') > -1 && name !== name.toUpperCase()) {
            context.report(node, "Identifier '{{name}}' is not in camel case.", { name: node.name });
          }
        }
      };
    };
  });
  require.define('/lib/rules/brace-style.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      function checkBlockStartsAtIdentifier(node) {
        var startLine = node.loc.start.line;
        if (node.body && startLine !== node.body.loc.start.line) {
          context.report(node, 'Opening curly brace does not appear on the same line as the block identifier.');
        }
        if (node.consequent && startLine !== node.consequent.loc.start.line) {
          context.report(node, 'Opening curly brace does not appear on the same line as the block identifier.');
        }
        if (node.block && startLine !== node.block.loc.start.line) {
          context.report(node, 'Opening curly brace does not appear on the same line as the block identifier.');
        }
        if (node.discriminant && startLine !== node.cases[0].loc.start.line - 1) {
          context.report(node, 'Opening curly brace does not appear on the same line as the block identifier.');
        }
      }
      return {
        'FunctionDeclaration': checkBlockStartsAtIdentifier,
        'IfStatement': checkBlockStartsAtIdentifier,
        'SwitchStatement': checkBlockStartsAtIdentifier,
        'TryStatement': checkBlockStartsAtIdentifier,
        'DoWhileStatement': checkBlockStartsAtIdentifier,
        'WhileStatement': checkBlockStartsAtIdentifier,
        'WithStatement': checkBlockStartsAtIdentifier,
        'ForStatement': checkBlockStartsAtIdentifier,
        'ForInStatement': checkBlockStartsAtIdentifier
      };
    };
  });
  require.define('/lib/rules/block-scoped-var.js', function (module, exports, __dirname, __filename) {
    module.exports = function (context) {
      'use strict';
      var stack = [{}];
      function pushBlock() {
        stack.push({});
      }
      function popBlock() {
        stack.pop();
      }
      function hasAllowedAncestorsForCheck(ancestors) {
        var grandparent = ancestors[ancestors.length - 1], belongsToFunction = grandparent.type === 'FunctionDeclaration';
        return belongsToFunction;
      }
      function addCommonDeclaration(node) {
        var type = node.type, topObject = stack.pop(), i, len, declarations;
        switch (type) {
        case 'VariableDeclaration':
          declarations = node.declarations;
          for (i = 0, len = declarations.length; i < len; i++) {
            topObject[declarations[i].id.name] = 1;
          }
          break;
        case 'FunctionDeclaration':
          declarations = node.params;
          topObject[node.id.name] = 1;
          for (i = 0, len = declarations.length; i < len; i++) {
            topObject[declarations[i].name] = 1;
          }
          break;
        case 'CatchClause':
          declarations = [];
          topObject[node.param.name] = 1;
        }
        stack.push(topObject);
      }
      function checkStackForIdentifier(node) {
        var i, len, ancestors = context.getAncestors();
        if (!hasAllowedAncestorsForCheck(ancestors)) {
          for (i = 0, len = stack.length; i < len; i++) {
            if (stack[i][node.name]) {
              return;
            }
          }
          context.report(node, node.name + ' used outside of binding context.');
        }
      }
      return {
        'BlockStatement': pushBlock,
        'BlockStatement:after': popBlock,
        'CatchClause': addCommonDeclaration,
        'VariableDeclaration': addCommonDeclaration,
        'FunctionDeclaration': addCommonDeclaration,
        'Identifier': checkStackForIdentifier
      };
    };
  });
  require.define('/conf/environments.json', function (module, exports, __dirname, __filename) {
    module.exports = {
      'builtin': {
        'NaN': false,
        'Infinity': false,
        'undefined': false,
        'eval': false,
        'parseFloat': false,
        'parseInt': false,
        'isNaN': false,
        'isFinite': false,
        'decodeURI': false,
        'decodeURIComponent': false,
        'encodeURI': false,
        'encodeURIComponent': false,
        'Object': false,
        'Function': false,
        'Array': false,
        'String': false,
        'Boolean': false,
        'Number': false,
        'Date': false,
        'RegExp': false,
        'Error': false,
        'EvalError': false,
        'RangeError': false,
        'ReferenceError': false,
        'SyntaxError': false,
        'TypeError': false,
        'URIError': false,
        'Math': false,
        'JSON': false
      },
      'browser': {
        'addEventListener': false,
        'applicationCache': false,
        'ArrayBuffer': false,
        'atob': false,
        'Audio': false,
        'Blob': false,
        'blur': false,
        'btoa': false,
        'cancelAnimationFrame': false,
        'clearInterval': false,
        'clearTimeout': false,
        'close': false,
        'closed': false,
        'crypto': false,
        'DataView': false,
        'defaultStatus': false,
        'devicePixelRatio': false,
        'dispatchEvent': false,
        'document': false,
        'DOMParser': false,
        'Element': false,
        'FileReader': false,
        'find': false,
        'Float32Array': false,
        'Float64Array': false,
        'focus': false,
        'FormData': false,
        'frameElement': false,
        'frames': false,
        'getComputedStyle': false,
        'getSelection': false,
        'history': false,
        'HTMLAnchorElement': false,
        'HTMLBaseElement': false,
        'HTMLBodyElement': false,
        'HTMLBRElement': false,
        'HTMLButtonElement': false,
        'HTMLCanvasElement': false,
        'HTMLDirectoryElement': false,
        'HTMLDivElement': false,
        'HTMLDListElement': false,
        'HTMLElement': false,
        'HTMLFieldSetElement': false,
        'HTMLFontElement': false,
        'HTMLFormElement': false,
        'HTMLFrameElement': false,
        'HTMLFrameSetElement': false,
        'HTMLHeadElement': false,
        'HTMLHeadingElement': false,
        'HTMLHRElement': false,
        'HTMLHtmlElement': false,
        'HTMLIFrameElement': false,
        'HTMLImageElement': false,
        'HTMLInputElement': false,
        'HTMLLabelElement': false,
        'HTMLLegendElement': false,
        'HTMLLIElement': false,
        'HTMLLinkElement': false,
        'HTMLMapElement': false,
        'HTMLMenuElement': false,
        'HTMLMetaElement': false,
        'HTMLModElement': false,
        'HTMLObjectElement': false,
        'HTMLOListElement': false,
        'HTMLOptGroupElement': false,
        'HTMLOptionElement': false,
        'HTMLParagraphElement': false,
        'HTMLParamElement': false,
        'HTMLPreElement': false,
        'HTMLQuoteElement': false,
        'HTMLScriptElement': false,
        'HTMLSelectElement': false,
        'HTMLStyleElement': false,
        'HTMLTableCaptionElement': false,
        'HTMLTableCellElement': false,
        'HTMLTableColElement': false,
        'HTMLTableElement': false,
        'HTMLTableRowElement': false,
        'HTMLTableSectionElement': false,
        'HTMLTextAreaElement': false,
        'HTMLTitleElement': false,
        'HTMLUListElement': false,
        'HTMLVideoElement': false,
        'Image': false,
        'indexedDB': false,
        'innerHeight': false,
        'innerWidth': false,
        'Int16Array': false,
        'Int32Array': false,
        'Int8Array': false,
        'Intl': false,
        'length': false,
        'localStorage': false,
        'location': false,
        'matchMedia': false,
        'MessageChannel': false,
        'MessageEvent': false,
        'MessagePort': false,
        'moveBy': false,
        'moveTo': false,
        'MutationObserver': false,
        'name': false,
        'navigator': false,
        'Node': false,
        'NodeFilter': false,
        'onbeforeunload': true,
        'onblur': true,
        'onerror': true,
        'onfocus': true,
        'onload': true,
        'onresize': true,
        'onunload': true,
        'open': false,
        'openDatabase': false,
        'opener': false,
        'Option': false,
        'outerHeight': false,
        'outerWidth': false,
        'pageXOffset': false,
        'pageYOffset': false,
        'parent': false,
        'postMessage': false,
        'print': false,
        'removeEventListener': false,
        'requestAnimationFrame': false,
        'resizeBy': false,
        'resizeTo': false,
        'screen': false,
        'screenX': false,
        'screenY': false,
        'scroll': false,
        'scrollbars': false,
        'scrollBy': false,
        'scrollTo': false,
        'scrollX': false,
        'scrollY': false,
        'self': false,
        'sessionStorage': false,
        'setInterval': false,
        'setTimeout': false,
        'SharedWorker': false,
        'showModalDialog': false,
        'stop': false,
        'SVGAElement': false,
        'SVGAltGlyphDefElement': false,
        'SVGAltGlyphElement': false,
        'SVGAltGlyphItemElement': false,
        'SVGAngle': false,
        'SVGAnimateColorElement': false,
        'SVGAnimatedAngle': false,
        'SVGAnimatedBoolean': false,
        'SVGAnimatedEnumeration': false,
        'SVGAnimatedInteger': false,
        'SVGAnimatedLength': false,
        'SVGAnimatedLengthList': false,
        'SVGAnimatedNumber': false,
        'SVGAnimatedNumberList': false,
        'SVGAnimatedPreserveAspectRatio': false,
        'SVGAnimatedRect': false,
        'SVGAnimatedString': false,
        'SVGAnimatedTransformList': false,
        'SVGAnimateElement': false,
        'SVGAnimateMotionElement': false,
        'SVGAnimateTransformElement': false,
        'SVGAnimationElement': false,
        'SVGCircleElement': false,
        'SVGClipPathElement': false,
        'SVGColor': false,
        'SVGComponentTransferFunctionElement': false,
        'SVGCursorElement': false,
        'SVGDefsElement': false,
        'SVGDescElement': false,
        'SVGDocument': false,
        'SVGElement': false,
        'SVGElementInstance': false,
        'SVGElementInstanceList': false,
        'SVGEllipseElement': false,
        'SVGFEBlendElement': false,
        'SVGFEColorMatrixElement': false,
        'SVGFEComponentTransferElement': false,
        'SVGFECompositeElement': false,
        'SVGFEConvolveMatrixElement': false,
        'SVGFEDiffuseLightingElement': false,
        'SVGFEDisplacementMapElement': false,
        'SVGFEDistantLightElement': false,
        'SVGFEFloodElement': false,
        'SVGFEFuncAElement': false,
        'SVGFEFuncBElement': false,
        'SVGFEFuncGElement': false,
        'SVGFEFuncRElement': false,
        'SVGFEGaussianBlurElement': false,
        'SVGFEImageElement': false,
        'SVGFEMergeElement': false,
        'SVGFEMergeNodeElement': false,
        'SVGFEMorphologyElement': false,
        'SVGFEOffsetElement': false,
        'SVGFEPointLightElement': false,
        'SVGFESpecularLightingElement': false,
        'SVGFESpotLightElement': false,
        'SVGFETileElement': false,
        'SVGFETurbulenceElement': false,
        'SVGFilterElement': false,
        'SVGFontElement': false,
        'SVGFontFaceElement': false,
        'SVGFontFaceFormatElement': false,
        'SVGFontFaceNameElement': false,
        'SVGFontFaceSrcElement': false,
        'SVGFontFaceUriElement': false,
        'SVGForeignObjectElement': false,
        'SVGGElement': false,
        'SVGGlyphElement': false,
        'SVGGlyphRefElement': false,
        'SVGGradientElement': false,
        'SVGHKernElement': false,
        'SVGImageElement': false,
        'SVGLength': false,
        'SVGLengthList': false,
        'SVGLinearGradientElement': false,
        'SVGLineElement': false,
        'SVGMarkerElement': false,
        'SVGMaskElement': false,
        'SVGMatrix': false,
        'SVGMetadataElement': false,
        'SVGMissingGlyphElement': false,
        'SVGMPathElement': false,
        'SVGNumber': false,
        'SVGNumberList': false,
        'SVGPaint': false,
        'SVGPathElement': false,
        'SVGPathSeg': false,
        'SVGPathSegArcAbs': false,
        'SVGPathSegArcRel': false,
        'SVGPathSegClosePath': false,
        'SVGPathSegCurvetoCubicAbs': false,
        'SVGPathSegCurvetoCubicRel': false,
        'SVGPathSegCurvetoCubicSmoothAbs': false,
        'SVGPathSegCurvetoCubicSmoothRel': false,
        'SVGPathSegCurvetoQuadraticAbs': false,
        'SVGPathSegCurvetoQuadraticRel': false,
        'SVGPathSegCurvetoQuadraticSmoothAbs': false,
        'SVGPathSegCurvetoQuadraticSmoothRel': false,
        'SVGPathSegLinetoAbs': false,
        'SVGPathSegLinetoHorizontalAbs': false,
        'SVGPathSegLinetoHorizontalRel': false,
        'SVGPathSegLinetoRel': false,
        'SVGPathSegLinetoVerticalAbs': false,
        'SVGPathSegLinetoVerticalRel': false,
        'SVGPathSegList': false,
        'SVGPathSegMovetoAbs': false,
        'SVGPathSegMovetoRel': false,
        'SVGPatternElement': false,
        'SVGPoint': false,
        'SVGPointList': false,
        'SVGPolygonElement': false,
        'SVGPolylineElement': false,
        'SVGPreserveAspectRatio': false,
        'SVGRadialGradientElement': false,
        'SVGRect': false,
        'SVGRectElement': false,
        'SVGRenderingIntent': false,
        'SVGScriptElement': false,
        'SVGSetElement': false,
        'SVGStopElement': false,
        'SVGStringList': false,
        'SVGStyleElement': false,
        'SVGSVGElement': false,
        'SVGSwitchElement': false,
        'SVGSymbolElement': false,
        'SVGTextContentElement': false,
        'SVGTextElement': false,
        'SVGTextPathElement': false,
        'SVGTextPositioningElement': false,
        'SVGTitleElement': false,
        'SVGTransform': false,
        'SVGTransformList': false,
        'SVGTRefElement': false,
        'SVGTSpanElement': false,
        'SVGUnitTypes': false,
        'SVGUseElement': false,
        'SVGViewElement': false,
        'SVGViewSpec': false,
        'SVGVKernElement': false,
        'top': false,
        'Uint16Array': false,
        'Uint32Array': false,
        'Uint8Array': false,
        'Uint8ClampedArray': false,
        'WebSocket': false,
        'window': false,
        'Worker': false,
        'XMLHttpRequest': false,
        'XMLSerializer': false,
        'XPathEvaluator': false,
        'XPathExpression': false,
        'XPathResult': false
      },
      'node': {
        '__filename': false,
        '__dirname': false,
        'Buffer': false,
        'DataView': false,
        'console': false,
        'exports': true,
        'GLOBAL': false,
        'global': false,
        'module': false,
        'process': false,
        'require': false,
        'setTimeout': false,
        'clearTimeout': false,
        'setInterval': false,
        'clearInterval': false,
        'setImmediate': false,
        'clearImmediate': false
      },
      'amd': {
        'require': false,
        'define': false
      }
    };
  });
  require.define('/node_modules/escope/escope.js', function (module, exports, __dirname, __filename) {
    (function (factory, global) {
      'use strict';
      function namespace(str, obj) {
        var i, iz, names, name;
        names = str.split('.');
        for (i = 0, iz = names.length; i < iz; ++i) {
          name = names[i];
          if (obj.hasOwnProperty(name)) {
            obj = obj[name];
          } else {
            obj = obj[name] = {};
          }
        }
        return obj;
      }
      if (typeof define === 'function' && define.amd) {
        define('escope', [
          'exports',
          'estraverse'
        ], function (exports, estraverse) {
          factory(exports, global, estraverse);
        });
      } else if (typeof exports !== 'undefined') {
        factory(exports, global, require('/node_modules/estraverse/estraverse.js', module));
      } else {
        factory(namespace('escope', global), global, global.estraverse);
      }
    }(function (exports, global, estraverse) {
      'use strict';
      var Syntax, Map, currentScope, globalScope, scopes, options;
      Syntax = estraverse.Syntax;
      if (typeof global.Map !== 'undefined') {
        Map = global.Map;
      } else {
        Map = function Map() {
          this.__data = {};
        };
        Map.prototype.get = function MapGet(key) {
          key = '$' + key;
          if (this.__data.hasOwnProperty(key)) {
            return this.__data[key];
          }
          return undefined;
        };
        Map.prototype.has = function MapHas(key) {
          key = '$' + key;
          return this.__data.hasOwnProperty(key);
        };
        Map.prototype.set = function MapSet(key, val) {
          key = '$' + key;
          this.__data[key] = val;
        };
        Map.prototype['delete'] = function MapDelete(key) {
          key = '$' + key;
          return delete this.__data[key];
        };
      }
      function assert(cond, text) {
        if (!cond) {
          throw new Error(text);
        }
      }
      function defaultOptions() {
        return {
          optimistic: false,
          directive: false
        };
      }
      function updateDeeply(target, override) {
        var key, val;
        function isHashObject(target) {
          return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }
        for (key in override) {
          if (override.hasOwnProperty(key)) {
            val = override[key];
            if (isHashObject(val)) {
              if (isHashObject(target[key])) {
                updateDeeply(target[key], val);
              } else {
                target[key] = updateDeeply({}, val);
              }
            } else {
              target[key] = val;
            }
          }
        }
        return target;
      }
      function Reference(ident, scope, flag, writeExpr, maybeImplicitGlobal) {
        this.identifier = ident;
        this.from = scope;
        this.tainted = false;
        this.resolved = null;
        this.flag = flag;
        if (this.isWrite()) {
          this.writeExpr = writeExpr;
        }
        this.__maybeImplicitGlobal = maybeImplicitGlobal;
      }
      Reference.READ = 1;
      Reference.WRITE = 2;
      Reference.RW = 3;
      Reference.prototype.isStatic = function isStatic() {
        return !this.tainted && this.resolved && this.resolved.scope.isStatic();
      };
      Reference.prototype.isWrite = function isWrite() {
        return this.flag & Reference.WRITE;
      };
      Reference.prototype.isRead = function isRead() {
        return this.flag & Reference.READ;
      };
      Reference.prototype.isReadOnly = function isReadOnly() {
        return this.flag === Reference.READ;
      };
      Reference.prototype.isWriteOnly = function isWriteOnly() {
        return this.flag === Reference.WRITE;
      };
      Reference.prototype.isReadWrite = function isReadWrite() {
        return this.flag === Reference.RW;
      };
      function Variable(name, scope) {
        this.name = name;
        this.identifiers = [];
        this.references = [];
        this.defs = [];
        this.tainted = false;
        this.stack = true;
        this.scope = scope;
      }
      Variable.CatchClause = 'CatchClause';
      Variable.Parameter = 'Parameter';
      Variable.FunctionName = 'FunctionName';
      Variable.Variable = 'Variable';
      Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';
      function isStrictScope(scope, block) {
        var body, i, iz, stmt, expr;
        if (scope.upper && scope.upper.isStrict) {
          return true;
        }
        if (scope.type === 'function') {
          body = block.body;
        } else if (scope.type === 'global') {
          body = block;
        } else {
          return false;
        }
        if (options.directive) {
          for (i = 0, iz = body.body.length; i < iz; ++i) {
            stmt = body.body[i];
            if (stmt.type !== 'DirectiveStatement') {
              break;
            }
            if (stmt.raw === '"use strict"' || stmt.raw === "'use strict'") {
              return true;
            }
          }
        } else {
          for (i = 0, iz = body.body.length; i < iz; ++i) {
            stmt = body.body[i];
            if (stmt.type !== Syntax.ExpressionStatement) {
              break;
            }
            expr = stmt.expression;
            if (expr.type !== Syntax.Literal || typeof expr.value !== 'string') {
              break;
            }
            if (expr.raw != null) {
              if (expr.raw === '"use strict"' || expr.raw === "'use strict'") {
                return true;
              }
            } else {
              if (expr.value === 'use strict') {
                return true;
              }
            }
          }
        }
        return false;
      }
      function Scope(block, opt) {
        var variable, body;
        this.type = block.type === Syntax.CatchClause ? 'catch' : block.type === Syntax.WithStatement ? 'with' : block.type === Syntax.Program ? 'global' : 'function';
        this.set = new Map;
        this.taints = new Map;
        this.dynamic = this.type === 'global' || this.type === 'with';
        this.block = block;
        this.through = [];
        this.variables = [];
        this.references = [];
        this.left = [];
        this.variableScope = this.type === 'global' || this.type === 'function' ? this : currentScope.variableScope;
        this.functionExpressionScope = false;
        this.directCallToEvalScope = false;
        this.thisFound = false;
        body = this.type === 'function' ? block.body : block;
        if (opt.naming) {
          this.__define(block.id, {
            type: Variable.FunctionName,
            name: block.id,
            node: block
          });
          this.functionExpressionScope = true;
        } else {
          if (this.type === 'function') {
            variable = new Variable('arguments', this);
            this.taints.set('arguments', true);
            this.set.set('arguments', variable);
            this.variables.push(variable);
          }
          if (block.type === Syntax.FunctionExpression && block.id) {
            new Scope(block, { naming: true });
          }
        }
        this.upper = currentScope;
        this.isStrict = isStrictScope(this, block);
        this.childScopes = [];
        if (currentScope) {
          currentScope.childScopes.push(this);
        }
        currentScope = this;
        if (this.type === 'global') {
          globalScope = this;
          globalScope.implicit = {
            set: new Map,
            variables: []
          };
        }
        scopes.push(this);
      }
      Scope.prototype.__close = function __close() {
        var i, iz, ref, current, node, implicit;
        if (!this.dynamic || options.optimistic) {
          for (i = 0, iz = this.left.length; i < iz; ++i) {
            ref = this.left[i];
            if (!this.__resolve(ref)) {
              this.__delegateToUpperScope(ref);
            }
          }
        } else {
          if (this.type === 'with') {
            for (i = 0, iz = this.left.length; i < iz; ++i) {
              ref = this.left[i];
              ref.tainted = true;
              this.__delegateToUpperScope(ref);
            }
          } else {
            for (i = 0, iz = this.left.length; i < iz; ++i) {
              ref = this.left[i];
              current = this;
              do {
                current.through.push(ref);
                current = current.upper;
              } while (current);
            }
          }
        }
        if (this.type === 'global') {
          implicit = [];
          for (i = 0, iz = this.left.length; i < iz; ++i) {
            ref = this.left[i];
            if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
              implicit.push(ref.__maybeImplicitGlobal);
            }
          }
          for (i = 0, iz = implicit.length; i < iz; ++i) {
            node = implicit[i];
            this.__defineImplicit(node.left, {
              type: Variable.ImplicitGlobalVariable,
              name: node.left,
              node: node
            });
          }
        }
        this.left = null;
        currentScope = this.upper;
      };
      Scope.prototype.__resolve = function __resolve(ref) {
        var variable, name;
        name = ref.identifier.name;
        if (this.set.has(name)) {
          variable = this.set.get(name);
          variable.references.push(ref);
          variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
          if (ref.tainted) {
            variable.tainted = true;
            this.taints.set(variable.name, true);
          }
          ref.resolved = variable;
          return true;
        }
        return false;
      };
      Scope.prototype.__delegateToUpperScope = function __delegateToUpperScope(ref) {
        if (this.upper) {
          this.upper.left.push(ref);
        }
        this.through.push(ref);
      };
      Scope.prototype.__defineImplicit = function __defineImplicit(node, info) {
        var name, variable;
        if (node && node.type === Syntax.Identifier) {
          name = node.name;
          if (!this.implicit.set.has(name)) {
            variable = new Variable(name, this);
            variable.identifiers.push(node);
            variable.defs.push(info);
            this.implicit.set.set(name, variable);
            this.implicit.variables.push(variable);
          } else {
            variable = this.implicit.set.get(name);
            variable.identifiers.push(node);
            variable.defs.push(info);
          }
        }
      };
      Scope.prototype.__define = function __define(node, info) {
        var name, variable;
        if (node && node.type === Syntax.Identifier) {
          name = node.name;
          if (!this.set.has(name)) {
            variable = new Variable(name, this);
            variable.identifiers.push(node);
            variable.defs.push(info);
            this.set.set(name, variable);
            this.variables.push(variable);
          } else {
            variable = this.set.get(name);
            variable.identifiers.push(node);
            variable.defs.push(info);
          }
        }
      };
      Scope.prototype.__referencing = function __referencing(node, assign, writeExpr, maybeImplicitGlobal) {
        var ref;
        if (node && node.type === Syntax.Identifier) {
          ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal);
          this.references.push(ref);
          this.left.push(ref);
        }
      };
      Scope.prototype.__detectEval = function __detectEval() {
        var current;
        current = this;
        this.directCallToEvalScope = true;
        do {
          current.dynamic = true;
          current = current.upper;
        } while (current);
      };
      Scope.prototype.__detectThis = function __detectThis() {
        this.thisFound = true;
      };
      Scope.prototype.__isClosed = function isClosed() {
        return this.left === null;
      };
      Scope.prototype.resolve = function resolve(ident) {
        var ref, i, iz;
        assert(this.__isClosed(), 'scope should be closed');
        assert(ident.type === Syntax.Identifier, 'target should be identifier');
        for (i = 0, iz = this.references.length; i < iz; ++i) {
          ref = this.references[i];
          if (ref.identifier === ident) {
            return ref;
          }
        }
        return null;
      };
      Scope.prototype.isStatic = function isStatic() {
        return !this.dynamic;
      };
      Scope.prototype.isArgumentsMaterialized = function isArgumentsMaterialized() {
        var variable;
        if (this.type !== 'function') {
          return true;
        }
        if (!this.isStatic()) {
          return true;
        }
        variable = this.set.get('arguments');
        assert(variable, 'always have arguments variable');
        return variable.tainted || variable.references.length !== 0;
      };
      Scope.prototype.isThisMaterialized = function isThisMaterialized() {
        if (this.type !== 'function') {
          return true;
        }
        if (!this.isStatic()) {
          return true;
        }
        return this.thisFound;
      };
      Scope.mangledName = '__$escope$__';
      Scope.prototype.attach = function attach() {
        if (!this.functionExpressionScope) {
          this.block[Scope.mangledName] = this;
        }
      };
      Scope.prototype.detach = function detach() {
        if (!this.functionExpressionScope) {
          delete this.block[Scope.mangledName];
        }
      };
      Scope.prototype.isUsedName = function (name) {
        if (this.set.has(name)) {
          return true;
        }
        for (var i = 0, iz = this.through.length; i < iz; ++i) {
          if (this.through[i].identifier.name === name) {
            return true;
          }
        }
        return false;
      };
      function ScopeManager(scopes) {
        this.scopes = scopes;
        this.attached = false;
      }
      ScopeManager.prototype.__get = function __get(node) {
        var i, iz, scope;
        if (this.attached) {
          return node[Scope.mangledName] || null;
        }
        if (Scope.isScopeRequired(node)) {
          for (i = 0, iz = this.scopes.length; i < iz; ++i) {
            scope = this.scopes[i];
            if (!scope.functionExpressionScope) {
              if (scope.block === node) {
                return scope;
              }
            }
          }
        }
        return null;
      };
      ScopeManager.prototype.acquire = function acquire(node) {
        return this.__get(node);
      };
      ScopeManager.prototype.release = function release(node) {
        var scope = this.__get(node);
        if (scope) {
          scope = scope.upper;
          while (scope) {
            if (!scope.functionExpressionScope) {
              return scope;
            }
            scope = scope.upper;
          }
        }
        return null;
      };
      ScopeManager.prototype.attach = function attach() {
        var i, iz;
        for (i = 0, iz = this.scopes.length; i < iz; ++i) {
          this.scopes[i].attach();
        }
        this.attached = true;
      };
      ScopeManager.prototype.detach = function detach() {
        var i, iz;
        for (i = 0, iz = this.scopes.length; i < iz; ++i) {
          this.scopes[i].detach();
        }
        this.attached = false;
      };
      Scope.isScopeRequired = function isScopeRequired(node) {
        return Scope.isVariableScopeRequired(node) || node.type === Syntax.WithStatement || node.type === Syntax.CatchClause;
      };
      Scope.isVariableScopeRequired = function isVariableScopeRequired(node) {
        return node.type === Syntax.Program || node.type === Syntax.FunctionExpression || node.type === Syntax.FunctionDeclaration;
      };
      function analyze(tree, providedOptions) {
        var resultScopes;
        options = updateDeeply(defaultOptions(), providedOptions);
        resultScopes = scopes = [];
        currentScope = null;
        globalScope = null;
        estraverse.traverse(tree, {
          enter: function enter(node) {
            var i, iz, decl;
            if (Scope.isScopeRequired(node)) {
              new Scope(node, {});
            }
            switch (node.type) {
            case Syntax.AssignmentExpression:
              if (node.operator === '=') {
                currentScope.__referencing(node.left, Reference.WRITE, node.right, !currentScope.isStrict && node.left.name != null && node);
              } else {
                currentScope.__referencing(node.left, Reference.RW, node.right);
              }
              currentScope.__referencing(node.right);
              break;
            case Syntax.ArrayExpression:
              for (i = 0, iz = node.elements.length; i < iz; ++i) {
                currentScope.__referencing(node.elements[i]);
              }
              break;
            case Syntax.BlockStatement:
              break;
            case Syntax.BinaryExpression:
              currentScope.__referencing(node.left);
              currentScope.__referencing(node.right);
              break;
            case Syntax.BreakStatement:
              break;
            case Syntax.CallExpression:
              currentScope.__referencing(node.callee);
              for (i = 0, iz = node['arguments'].length; i < iz; ++i) {
                currentScope.__referencing(node['arguments'][i]);
              }
              if (!options.ignoreEval && node.callee.type === Syntax.Identifier && node.callee.name === 'eval') {
                currentScope.variableScope.__detectEval();
              }
              break;
            case Syntax.CatchClause:
              currentScope.__define(node.param, {
                type: Variable.CatchClause,
                name: node.param,
                node: node
              });
              break;
            case Syntax.ConditionalExpression:
              currentScope.__referencing(node.test);
              currentScope.__referencing(node.consequent);
              currentScope.__referencing(node.alternate);
              break;
            case Syntax.ContinueStatement:
              break;
            case Syntax.DirectiveStatement:
              break;
            case Syntax.DoWhileStatement:
              currentScope.__referencing(node.test);
              break;
            case Syntax.DebuggerStatement:
              break;
            case Syntax.EmptyStatement:
              break;
            case Syntax.ExpressionStatement:
              currentScope.__referencing(node.expression);
              break;
            case Syntax.ForStatement:
              currentScope.__referencing(node.init);
              currentScope.__referencing(node.test);
              currentScope.__referencing(node.update);
              break;
            case Syntax.ForInStatement:
              if (node.left.type === Syntax.VariableDeclaration) {
                currentScope.__referencing(node.left.declarations[0].id, Reference.WRITE, null, false);
              } else {
                currentScope.__referencing(node.left, Reference.WRITE, null, !currentScope.isStrict && node.left.name != null && node);
              }
              currentScope.__referencing(node.right);
              break;
            case Syntax.FunctionDeclaration:
              currentScope.upper.__define(node.id, {
                type: Variable.FunctionName,
                name: node.id,
                node: node
              });
              for (i = 0, iz = node.params.length; i < iz; ++i) {
                currentScope.__define(node.params[i], {
                  type: Variable.Parameter,
                  name: node.params[i],
                  node: node,
                  index: i
                });
              }
              break;
            case Syntax.FunctionExpression:
              for (i = 0, iz = node.params.length; i < iz; ++i) {
                currentScope.__define(node.params[i], {
                  type: Variable.Parameter,
                  name: node.params[i],
                  node: node,
                  index: i
                });
              }
              break;
            case Syntax.Identifier:
              break;
            case Syntax.IfStatement:
              currentScope.__referencing(node.test);
              break;
            case Syntax.Literal:
              break;
            case Syntax.LabeledStatement:
              break;
            case Syntax.LogicalExpression:
              currentScope.__referencing(node.left);
              currentScope.__referencing(node.right);
              break;
            case Syntax.MemberExpression:
              currentScope.__referencing(node.object);
              if (node.computed) {
                currentScope.__referencing(node.property);
              }
              break;
            case Syntax.NewExpression:
              currentScope.__referencing(node.callee);
              for (i = 0, iz = node['arguments'].length; i < iz; ++i) {
                currentScope.__referencing(node['arguments'][i]);
              }
              break;
            case Syntax.ObjectExpression:
              break;
            case Syntax.Program:
              break;
            case Syntax.Property:
              currentScope.__referencing(node.value);
              break;
            case Syntax.ReturnStatement:
              currentScope.__referencing(node.argument);
              break;
            case Syntax.SequenceExpression:
              for (i = 0, iz = node.expressions.length; i < iz; ++i) {
                currentScope.__referencing(node.expressions[i]);
              }
              break;
            case Syntax.SwitchStatement:
              currentScope.__referencing(node.discriminant);
              break;
            case Syntax.SwitchCase:
              currentScope.__referencing(node.test);
              break;
            case Syntax.ThisExpression:
              currentScope.variableScope.__detectThis();
              break;
            case Syntax.ThrowStatement:
              currentScope.__referencing(node.argument);
              break;
            case Syntax.TryStatement:
              break;
            case Syntax.UnaryExpression:
              currentScope.__referencing(node.argument);
              break;
            case Syntax.UpdateExpression:
              currentScope.__referencing(node.argument, Reference.RW, null);
              break;
            case Syntax.VariableDeclaration:
              for (i = 0, iz = node.declarations.length; i < iz; ++i) {
                decl = node.declarations[i];
                currentScope.variableScope.__define(decl.id, {
                  type: Variable.Variable,
                  name: decl.id,
                  node: decl,
                  index: i,
                  parent: node
                });
                if (decl.init) {
                  currentScope.__referencing(decl.id, Reference.WRITE, decl.init, false);
                  currentScope.__referencing(decl.init);
                }
              }
              break;
            case Syntax.VariableDeclarator:
              break;
            case Syntax.WhileStatement:
              currentScope.__referencing(node.test);
              break;
            case Syntax.WithStatement:
              currentScope.upper.__referencing(node.object);
              break;
            }
          },
          leave: function leave(node) {
            while (currentScope && node === currentScope.block) {
              currentScope.__close();
            }
          }
        });
        assert(currentScope === null);
        globalScope = null;
        scopes = null;
        options = null;
        return new ScopeManager(resultScopes);
      }
      exports.version = '1.0.0';
      exports.Reference = Reference;
      exports.Variable = Variable;
      exports.Scope = Scope;
      exports.ScopeManager = ScopeManager;
      exports.analyze = analyze;
    }, this));
  });
  require.define('/node_modules/estraverse/estraverse.js', function (module, exports, __dirname, __filename) {
    (function (root, factory) {
      'use strict';
      if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
      } else if (typeof exports !== 'undefined') {
        factory(exports);
      } else {
        factory(root.estraverse = {});
      }
    }(this, function (exports) {
      'use strict';
      var Syntax, isArray, VisitorOption, VisitorKeys, BREAK, SKIP;
      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
      };
      function ignoreJSHintError() {
      }
      isArray = Array.isArray;
      if (!isArray) {
        isArray = function isArray(array) {
          return Object.prototype.toString.call(array) === '[object Array]';
        };
      }
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === 'object' && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
      ignoreJSHintError(shallowCopy);
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      function lowerBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            i = current + 1;
            len -= diff + 1;
          } else {
            len = diff;
          }
        }
        return i;
      }
      ignoreJSHintError(lowerBound);
      VisitorKeys = {
        AssignmentExpression: [
          'left',
          'right'
        ],
        ArrayExpression: ['elements'],
        ArrowFunctionExpression: [
          'params',
          'body'
        ],
        BlockStatement: ['body'],
        BinaryExpression: [
          'left',
          'right'
        ],
        BreakStatement: ['label'],
        CallExpression: [
          'callee',
          'arguments'
        ],
        CatchClause: [
          'param',
          'body'
        ],
        ClassBody: ['body'],
        ClassDeclaration: [
          'id',
          'body',
          'superClass'
        ],
        ClassExpression: [
          'id',
          'body',
          'superClass'
        ],
        ConditionalExpression: [
          'test',
          'consequent',
          'alternate'
        ],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: [
          'body',
          'test'
        ],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForStatement: [
          'init',
          'test',
          'update',
          'body'
        ],
        ForInStatement: [
          'left',
          'right',
          'body'
        ],
        FunctionDeclaration: [
          'id',
          'params',
          'body'
        ],
        FunctionExpression: [
          'id',
          'params',
          'body'
        ],
        Identifier: [],
        IfStatement: [
          'test',
          'consequent',
          'alternate'
        ],
        Literal: [],
        LabeledStatement: [
          'label',
          'body'
        ],
        LogicalExpression: [
          'left',
          'right'
        ],
        MemberExpression: [
          'object',
          'property'
        ],
        MethodDefinition: [
          'key',
          'value'
        ],
        NewExpression: [
          'callee',
          'arguments'
        ],
        ObjectExpression: ['properties'],
        Program: ['body'],
        Property: [
          'key',
          'value'
        ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchStatement: [
          'discriminant',
          'cases'
        ],
        SwitchCase: [
          'test',
          'consequent'
        ],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: [
          'block',
          'handlers',
          'handler',
          'guardedHandlers',
          'finalizer'
        ],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: [
          'id',
          'init'
        ],
        WhileStatement: [
          'test',
          'body'
        ],
        WithStatement: [
          'object',
          'body'
        ],
        YieldExpression: ['argument']
      };
      BREAK = {};
      SKIP = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
      };
      function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;
        function addToPath(result, path) {
          if (isArray(path)) {
            for (j = 0, jz = path.length; j < jz; ++j) {
              result.push(path[j]);
            }
          } else {
            result.push(path);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = undefined;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function () {
        this.notify(SKIP);
      };
      Controller.prototype['break'] = function () {
        this.notify(BREAK);
      };
      Controller.prototype.__initialize = function (root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
      };
      Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = element.wrap || node.type;
            candidates = VisitorKeys[nodeType];
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (!isArray(candidate)) {
                worklist.push(new Element(candidate, key, null, null));
                continue;
              }
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], 'Property', null);
                } else {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], null, null);
                }
                worklist.push(element);
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = { root: root };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== undefined && target !== BREAK && target !== SKIP) {
              element.ref.replace(target);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== undefined && target !== BREAK && target !== SKIP) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = element.wrap || node.type;
          candidates = VisitorKeys[nodeType];
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (!isArray(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
              continue;
            }
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                element = new Element(candidate[current2], [
                  key,
                  current2
                ], 'Property', new Reference(candidate, current2));
              } else {
                element = new Element(candidate[current2], [
                  key,
                  current2
                ], null, new Reference(candidate, current2));
              }
              worklist.push(element);
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller;
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller;
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [
          comment.range[0],
          comment.range[1]
        ];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error('attachComments needs range information');
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [
                0,
                tree.range[0]
              ];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (comment.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (node.range[1] < comment.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports.version = '1.3.2';
      exports.Syntax = Syntax;
      exports.traverse = traverse;
      exports.replace = replace;
      exports.attachComments = attachComments;
      exports.VisitorKeys = VisitorKeys;
      exports.VisitorOption = VisitorOption;
      exports.Controller = Controller;
    }));
  });
  require.define('/node_modules/esprima/esprima.js', function (module, exports, __dirname, __filename) {
    (function (root, factory) {
      'use strict';
      if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
      } else if (typeof exports !== 'undefined') {
        factory(exports);
      } else {
        factory(root.esprima = {});
      }
    }(this, function (exports) {
      'use strict';
      var Token, TokenName, Syntax, PropertyKind, Messages, Regex, source, strict, index, lineNumber, lineStart, length, buffer, state, extra;
      Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8
      };
      TokenName = {};
      TokenName[Token.BooleanLiteral] = 'Boolean';
      TokenName[Token.EOF] = '<end>';
      TokenName[Token.Identifier] = 'Identifier';
      TokenName[Token.Keyword] = 'Keyword';
      TokenName[Token.NullLiteral] = 'Null';
      TokenName[Token.NumericLiteral] = 'Numeric';
      TokenName[Token.Punctuator] = 'Punctuator';
      TokenName[Token.StringLiteral] = 'String';
      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
      };
      PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
      };
      Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: "Undefined label '%0'",
        Redeclaration: "%0 '%1' has already been declared",
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode'
      };
      Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
      };
      function assert(condition, message) {
        if (!condition) {
          throw new Error('ASSERT: ' + message);
        }
      }
      function sliceSource(from, to) {
        return source.slice(from, to);
      }
      if (typeof 'esprima'[0] === 'undefined') {
        sliceSource = function sliceArraySource(from, to) {
          return source.slice(from, to).join('');
        };
      }
      function isDecimalDigit(ch) {
        return '0123456789'.indexOf(ch) >= 0;
      }
      function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
      }
      function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
      }
      function isWhiteSpace(ch) {
        return ch === ' ' || ch === '\t' || ch === '\x0B' || ch === '\f' || ch === '\xa0' || ch.charCodeAt(0) >= 5760 && '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\ufeff'.indexOf(ch) >= 0;
      }
      function isLineTerminator(ch) {
        return ch === '\n' || ch === '\r' || ch === '\u2028' || ch === '\u2029';
      }
      function isIdentifierStart(ch) {
        return ch === '$' || ch === '_' || ch === '\\' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch.charCodeAt(0) >= 128 && Regex.NonAsciiIdentifierStart.test(ch);
      }
      function isIdentifierPart(ch) {
        return ch === '$' || ch === '_' || ch === '\\' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch.charCodeAt(0) >= 128 && Regex.NonAsciiIdentifierPart.test(ch);
      }
      function isFutureReservedWord(id) {
        switch (id) {
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
          return true;
        }
        return false;
      }
      function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
          return true;
        }
        return false;
      }
      function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
      }
      function isKeyword(id) {
        var keyword = false;
        switch (id.length) {
        case 2:
          keyword = id === 'if' || id === 'in' || id === 'do';
          break;
        case 3:
          keyword = id === 'var' || id === 'for' || id === 'new' || id === 'try';
          break;
        case 4:
          keyword = id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with';
          break;
        case 5:
          keyword = id === 'while' || id === 'break' || id === 'catch' || id === 'throw';
          break;
        case 6:
          keyword = id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch';
          break;
        case 7:
          keyword = id === 'default' || id === 'finally';
          break;
        case 8:
          keyword = id === 'function' || id === 'continue' || id === 'debugger';
          break;
        case 10:
          keyword = id === 'instanceof';
          break;
        }
        if (keyword) {
          return true;
        }
        switch (id) {
        case 'const':
          return true;
        case 'yield':
        case 'let':
          return true;
        }
        if (strict && isStrictModeReservedWord(id)) {
          return true;
        }
        return isFutureReservedWord(id);
      }
      function skipComment() {
        var ch, blockComment, lineComment;
        blockComment = false;
        lineComment = false;
        while (index < length) {
          ch = source[index];
          if (lineComment) {
            ch = source[index++];
            if (isLineTerminator(ch)) {
              lineComment = false;
              if (ch === '\r' && source[index] === '\n') {
                ++index;
              }
              ++lineNumber;
              lineStart = index;
            }
          } else if (blockComment) {
            if (isLineTerminator(ch)) {
              if (ch === '\r' && source[index + 1] === '\n') {
                ++index;
              }
              ++lineNumber;
              ++index;
              lineStart = index;
              if (index >= length) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
            } else {
              ch = source[index++];
              if (index >= length) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
              if (ch === '*') {
                ch = source[index];
                if (ch === '/') {
                  ++index;
                  blockComment = false;
                }
              }
            }
          } else if (ch === '/') {
            ch = source[index + 1];
            if (ch === '/') {
              index += 2;
              lineComment = true;
            } else if (ch === '*') {
              index += 2;
              blockComment = true;
              if (index >= length) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
            } else {
              break;
            }
          } else if (isWhiteSpace(ch)) {
            ++index;
          } else if (isLineTerminator(ch)) {
            ++index;
            if (ch === '\r' && source[index] === '\n') {
              ++index;
            }
            ++lineNumber;
            lineStart = index;
          } else {
            break;
          }
        }
      }
      function scanHexEscape(prefix) {
        var i, len, ch, code = 0;
        len = prefix === 'u' ? 4 : 2;
        for (i = 0; i < len; ++i) {
          if (index < length && isHexDigit(source[index])) {
            ch = source[index++];
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
          } else {
            return '';
          }
        }
        return String.fromCharCode(code);
      }
      function scanIdentifier() {
        var ch, start, id, restore;
        ch = source[index];
        if (!isIdentifierStart(ch)) {
          return;
        }
        start = index;
        if (ch === '\\') {
          ++index;
          if (source[index] !== 'u') {
            return;
          }
          ++index;
          restore = index;
          ch = scanHexEscape('u');
          if (ch) {
            if (ch === '\\' || !isIdentifierStart(ch)) {
              return;
            }
            id = ch;
          } else {
            index = restore;
            id = 'u';
          }
        } else {
          id = source[index++];
        }
        while (index < length) {
          ch = source[index];
          if (!isIdentifierPart(ch)) {
            break;
          }
          if (ch === '\\') {
            ++index;
            if (source[index] !== 'u') {
              return;
            }
            ++index;
            restore = index;
            ch = scanHexEscape('u');
            if (ch) {
              if (ch === '\\' || !isIdentifierPart(ch)) {
                return;
              }
              id += ch;
            } else {
              index = restore;
              id += 'u';
            }
          } else {
            id += source[index++];
          }
        }
        if (id.length === 1) {
          return {
            type: Token.Identifier,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        if (isKeyword(id)) {
          return {
            type: Token.Keyword,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        if (id === 'null') {
          return {
            type: Token.NullLiteral,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        if (id === 'true' || id === 'false') {
          return {
            type: Token.BooleanLiteral,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        return {
          type: Token.Identifier,
          value: id,
          lineNumber: lineNumber,
          lineStart: lineStart,
          range: [
            start,
            index
          ]
        };
      }
      function scanPunctuator() {
        var start = index, ch1 = source[index], ch2, ch3, ch4;
        if (ch1 === ';' || ch1 === '{' || ch1 === '}') {
          ++index;
          return {
            type: Token.Punctuator,
            value: ch1,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        if (ch1 === ',' || ch1 === '(' || ch1 === ')') {
          ++index;
          return {
            type: Token.Punctuator,
            value: ch1,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        ch2 = source[index + 1];
        if (ch1 === '.' && !isDecimalDigit(ch2)) {
          return {
            type: Token.Punctuator,
            value: source[index++],
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        ch3 = source[index + 2];
        ch4 = source[index + 3];
        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
          if (ch4 === '=') {
            index += 4;
            return {
              type: Token.Punctuator,
              value: '>>>=',
              lineNumber: lineNumber,
              lineStart: lineStart,
              range: [
                start,
                index
              ]
            };
          }
        }
        if (ch1 === '=' && ch2 === '=' && ch3 === '=') {
          index += 3;
          return {
            type: Token.Punctuator,
            value: '===',
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        if (ch1 === '!' && ch2 === '=' && ch3 === '=') {
          index += 3;
          return {
            type: Token.Punctuator,
            value: '!==',
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
          index += 3;
          return {
            type: Token.Punctuator,
            value: '>>>',
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
          index += 3;
          return {
            type: Token.Punctuator,
            value: '<<=',
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
          index += 3;
          return {
            type: Token.Punctuator,
            value: '>>=',
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
        if (ch2 === '=') {
          if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            index += 2;
            return {
              type: Token.Punctuator,
              value: ch1 + ch2,
              lineNumber: lineNumber,
              lineStart: lineStart,
              range: [
                start,
                index
              ]
            };
          }
        }
        if (ch1 === ch2 && '+-<>&|'.indexOf(ch1) >= 0) {
          if ('+-<>&|'.indexOf(ch2) >= 0) {
            index += 2;
            return {
              type: Token.Punctuator,
              value: ch1 + ch2,
              lineNumber: lineNumber,
              lineStart: lineStart,
              range: [
                start,
                index
              ]
            };
          }
        }
        if ('[]<>+-*%&|^!~?:=/'.indexOf(ch1) >= 0) {
          return {
            type: Token.Punctuator,
            value: source[index++],
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              start,
              index
            ]
          };
        }
      }
      function scanNumericLiteral() {
        var number, start, ch;
        ch = source[index];
        assert(isDecimalDigit(ch) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
        start = index;
        number = '';
        if (ch !== '.') {
          number = source[index++];
          ch = source[index];
          if (number === '0') {
            if (ch === 'x' || ch === 'X') {
              number += source[index++];
              while (index < length) {
                ch = source[index];
                if (!isHexDigit(ch)) {
                  break;
                }
                number += source[index++];
              }
              if (number.length <= 2) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
              if (index < length) {
                ch = source[index];
                if (isIdentifierStart(ch)) {
                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
              }
              return {
                type: Token.NumericLiteral,
                value: parseInt(number, 16),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                  start,
                  index
                ]
              };
            } else if (isOctalDigit(ch)) {
              number += source[index++];
              while (index < length) {
                ch = source[index];
                if (!isOctalDigit(ch)) {
                  break;
                }
                number += source[index++];
              }
              if (index < length) {
                ch = source[index];
                if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
              }
              return {
                type: Token.NumericLiteral,
                value: parseInt(number, 8),
                octal: true,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                  start,
                  index
                ]
              };
            }
            if (isDecimalDigit(ch)) {
              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
          }
          while (index < length) {
            ch = source[index];
            if (!isDecimalDigit(ch)) {
              break;
            }
            number += source[index++];
          }
        }
        if (ch === '.') {
          number += source[index++];
          while (index < length) {
            ch = source[index];
            if (!isDecimalDigit(ch)) {
              break;
            }
            number += source[index++];
          }
        }
        if (ch === 'e' || ch === 'E') {
          number += source[index++];
          ch = source[index];
          if (ch === '+' || ch === '-') {
            number += source[index++];
          }
          ch = source[index];
          if (isDecimalDigit(ch)) {
            number += source[index++];
            while (index < length) {
              ch = source[index];
              if (!isDecimalDigit(ch)) {
                break;
              }
              number += source[index++];
            }
          } else {
            ch = 'character ' + ch;
            if (index >= length) {
              ch = '<end>';
            }
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
          }
        }
        if (index < length) {
          ch = source[index];
          if (isIdentifierStart(ch)) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
          }
        }
        return {
          type: Token.NumericLiteral,
          value: parseFloat(number),
          lineNumber: lineNumber,
          lineStart: lineStart,
          range: [
            start,
            index
          ]
        };
      }
      function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false;
        quote = source[index];
        assert(quote === "'" || quote === '"', 'String literal must starts with a quote');
        start = index;
        ++index;
        while (index < length) {
          ch = source[index++];
          if (ch === quote) {
            quote = '';
            break;
          } else if (ch === '\\') {
            ch = source[index++];
            if (!isLineTerminator(ch)) {
              switch (ch) {
              case 'n':
                str += '\n';
                break;
              case 'r':
                str += '\r';
                break;
              case 't':
                str += '\t';
                break;
              case 'u':
              case 'x':
                restore = index;
                unescaped = scanHexEscape(ch);
                if (unescaped) {
                  str += unescaped;
                } else {
                  index = restore;
                  str += ch;
                }
                break;
              case 'b':
                str += '\b';
                break;
              case 'f':
                str += '\f';
                break;
              case 'v':
                str += '\x0B';
                break;
              default:
                if (isOctalDigit(ch)) {
                  code = '01234567'.indexOf(ch);
                  if (code !== 0) {
                    octal = true;
                  }
                  if (index < length && isOctalDigit(source[index])) {
                    octal = true;
                    code = code * 8 + '01234567'.indexOf(source[index++]);
                    if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                      code = code * 8 + '01234567'.indexOf(source[index++]);
                    }
                  }
                  str += String.fromCharCode(code);
                } else {
                  str += ch;
                }
                break;
              }
            } else {
              ++lineNumber;
              if (ch === '\r' && source[index] === '\n') {
                ++index;
              }
            }
          } else if (isLineTerminator(ch)) {
            break;
          } else {
            str += ch;
          }
        }
        if (quote !== '') {
          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        return {
          type: Token.StringLiteral,
          value: str,
          octal: octal,
          lineNumber: lineNumber,
          lineStart: lineStart,
          range: [
            start,
            index
          ]
        };
      }
      function scanRegExp() {
        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;
        buffer = null;
        skipComment();
        start = index;
        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];
        while (index < length) {
          ch = source[index++];
          str += ch;
          if (ch === '\\') {
            ch = source[index++];
            if (isLineTerminator(ch)) {
              throwError({}, Messages.UnterminatedRegExp);
            }
            str += ch;
          } else if (classMarker) {
            if (ch === ']') {
              classMarker = false;
            }
          } else {
            if (ch === '/') {
              terminated = true;
              break;
            } else if (ch === '[') {
              classMarker = true;
            } else if (isLineTerminator(ch)) {
              throwError({}, Messages.UnterminatedRegExp);
            }
          }
        }
        if (!terminated) {
          throwError({}, Messages.UnterminatedRegExp);
        }
        pattern = str.substr(1, str.length - 2);
        flags = '';
        while (index < length) {
          ch = source[index];
          if (!isIdentifierPart(ch)) {
            break;
          }
          ++index;
          if (ch === '\\' && index < length) {
            ch = source[index];
            if (ch === 'u') {
              ++index;
              restore = index;
              ch = scanHexEscape('u');
              if (ch) {
                flags += ch;
                str += '\\u';
                for (; restore < index; ++restore) {
                  str += source[restore];
                }
              } else {
                index = restore;
                flags += 'u';
                str += '\\u';
              }
            } else {
              str += '\\';
            }
          } else {
            flags += ch;
            str += ch;
          }
        }
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
          throwError({}, Messages.InvalidRegExp);
        }
        return {
          literal: str,
          value: value,
          range: [
            start,
            index
          ]
        };
      }
      function isIdentifierName(token) {
        return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
      }
      function advance() {
        var ch, token;
        skipComment();
        if (index >= length) {
          return {
            type: Token.EOF,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [
              index,
              index
            ]
          };
        }
        token = scanPunctuator();
        if (typeof token !== 'undefined') {
          return token;
        }
        ch = source[index];
        if (ch === "'" || ch === '"') {
          return scanStringLiteral();
        }
        if (ch === '.' || isDecimalDigit(ch)) {
          return scanNumericLiteral();
        }
        token = scanIdentifier();
        if (typeof token !== 'undefined') {
          return token;
        }
        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
      }
      function lex() {
        var token;
        if (buffer) {
          index = buffer.range[1];
          lineNumber = buffer.lineNumber;
          lineStart = buffer.lineStart;
          token = buffer;
          buffer = null;
          return token;
        }
        buffer = null;
        return advance();
      }
      function lookahead() {
        var pos, line, start;
        if (buffer !== null) {
          return buffer;
        }
        pos = index;
        line = lineNumber;
        start = lineStart;
        buffer = advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
        return buffer;
      }
      function peekLineTerminator() {
        var pos, line, start, found;
        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;
        return found;
      }
      function throwError(token, messageFormat) {
        var error, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, function (whole, index) {
            return args[index] || '';
          });
        if (typeof token.lineNumber === 'number') {
          error = new Error('Line ' + token.lineNumber + ': ' + msg);
          error.index = token.range[0];
          error.lineNumber = token.lineNumber;
          error.column = token.range[0] - lineStart + 1;
        } else {
          error = new Error('Line ' + lineNumber + ': ' + msg);
          error.index = index;
          error.lineNumber = lineNumber;
          error.column = index - lineStart + 1;
        }
        throw error;
      }
      function throwErrorTolerant() {
        try {
          throwError.apply(null, arguments);
        } catch (e) {
          if (extra.errors) {
            extra.errors.push(e);
          } else {
            throw e;
          }
        }
      }
      function throwUnexpected(token) {
        if (token.type === Token.EOF) {
          throwError(token, Messages.UnexpectedEOS);
        }
        if (token.type === Token.NumericLiteral) {
          throwError(token, Messages.UnexpectedNumber);
        }
        if (token.type === Token.StringLiteral) {
          throwError(token, Messages.UnexpectedString);
        }
        if (token.type === Token.Identifier) {
          throwError(token, Messages.UnexpectedIdentifier);
        }
        if (token.type === Token.Keyword) {
          if (isFutureReservedWord(token.value)) {
            throwError(token, Messages.UnexpectedReserved);
          } else if (strict && isStrictModeReservedWord(token.value)) {
            throwErrorTolerant(token, Messages.StrictReservedWord);
            return;
          }
          throwError(token, Messages.UnexpectedToken, token.value);
        }
        throwError(token, Messages.UnexpectedToken, token.value);
      }
      function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
          throwUnexpected(token);
        }
      }
      function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
          throwUnexpected(token);
        }
      }
      function match(value) {
        var token = lookahead();
        return token.type === Token.Punctuator && token.value === value;
      }
      function matchKeyword(keyword) {
        var token = lookahead();
        return token.type === Token.Keyword && token.value === keyword;
      }
      function matchAssign() {
        var token = lookahead(), op = token.value;
        if (token.type !== Token.Punctuator) {
          return false;
        }
        return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
      }
      function consumeSemicolon() {
        var token, line;
        if (source[index] === ';') {
          lex();
          return;
        }
        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
          return;
        }
        if (match(';')) {
          lex();
          return;
        }
        token = lookahead();
        if (token.type !== Token.EOF && !match('}')) {
          throwUnexpected(token);
        }
      }
      function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
      }
      function parseArrayInitialiser() {
        var elements = [];
        expect('[');
        while (!match(']')) {
          if (match(',')) {
            lex();
            elements.push(null);
          } else {
            elements.push(parseAssignmentExpression());
            if (!match(']')) {
              expect(',');
            }
          }
        }
        expect(']');
        return {
          type: Syntax.ArrayExpression,
          elements: elements
        };
      }
      function parsePropertyFunction(param, first) {
        var previousStrict, body;
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
          throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return {
          type: Syntax.FunctionExpression,
          id: null,
          params: param,
          defaults: [],
          body: body,
          rest: null,
          generator: false,
          expression: false
        };
      }
      function parseObjectPropertyKey() {
        var token = lex();
        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
          if (strict && token.octal) {
            throwErrorTolerant(token, Messages.StrictOctalLiteral);
          }
          return createLiteral(token);
        }
        return {
          type: Syntax.Identifier,
          name: token.value
        };
      }
      function parseObjectProperty() {
        var token, key, id, param;
        token = lookahead();
        if (token.type === Token.Identifier) {
          id = parseObjectPropertyKey();
          if (token.value === 'get' && !match(':')) {
            key = parseObjectPropertyKey();
            expect('(');
            expect(')');
            return {
              type: Syntax.Property,
              key: key,
              value: parsePropertyFunction([]),
              kind: 'get'
            };
          } else if (token.value === 'set' && !match(':')) {
            key = parseObjectPropertyKey();
            expect('(');
            token = lookahead();
            if (token.type !== Token.Identifier) {
              expect(')');
              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
              return {
                type: Syntax.Property,
                key: key,
                value: parsePropertyFunction([]),
                kind: 'set'
              };
            } else {
              param = [parseVariableIdentifier()];
              expect(')');
              return {
                type: Syntax.Property,
                key: key,
                value: parsePropertyFunction(param, token),
                kind: 'set'
              };
            }
          } else {
            expect(':');
            return {
              type: Syntax.Property,
              key: id,
              value: parseAssignmentExpression(),
              kind: 'init'
            };
          }
        } else if (token.type === Token.EOF || token.type === Token.Punctuator) {
          throwUnexpected(token);
        } else {
          key = parseObjectPropertyKey();
          expect(':');
          return {
            type: Syntax.Property,
            key: key,
            value: parseAssignmentExpression(),
            kind: 'init'
          };
        }
      }
      function parseObjectInitialiser() {
        var properties = [], property, name, kind, map = {}, toString = String;
        expect('{');
        while (!match('}')) {
          property = parseObjectProperty();
          if (property.key.type === Syntax.Identifier) {
            name = property.key.name;
          } else {
            name = toString(property.key.value);
          }
          kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;
          if (Object.prototype.hasOwnProperty.call(map, name)) {
            if (map[name] === PropertyKind.Data) {
              if (strict && kind === PropertyKind.Data) {
                throwErrorTolerant({}, Messages.StrictDuplicateProperty);
              } else if (kind !== PropertyKind.Data) {
                throwErrorTolerant({}, Messages.AccessorDataProperty);
              }
            } else {
              if (kind === PropertyKind.Data) {
                throwErrorTolerant({}, Messages.AccessorDataProperty);
              } else if (map[name] & kind) {
                throwErrorTolerant({}, Messages.AccessorGetSet);
              }
            }
            map[name] |= kind;
          } else {
            map[name] = kind;
          }
          properties.push(property);
          if (!match('}')) {
            expect(',');
          }
        }
        expect('}');
        return {
          type: Syntax.ObjectExpression,
          properties: properties
        };
      }
      function parseGroupExpression() {
        var expr;
        expect('(');
        expr = parseExpression();
        expect(')');
        return expr;
      }
      function parsePrimaryExpression() {
        var token = lookahead(), type = token.type;
        if (type === Token.Identifier) {
          return {
            type: Syntax.Identifier,
            name: lex().value
          };
        }
        if (type === Token.StringLiteral || type === Token.NumericLiteral) {
          if (strict && token.octal) {
            throwErrorTolerant(token, Messages.StrictOctalLiteral);
          }
          return createLiteral(lex());
        }
        if (type === Token.Keyword) {
          if (matchKeyword('this')) {
            lex();
            return { type: Syntax.ThisExpression };
          }
          if (matchKeyword('function')) {
            return parseFunctionExpression();
          }
        }
        if (type === Token.BooleanLiteral) {
          lex();
          token.value = token.value === 'true';
          return createLiteral(token);
        }
        if (type === Token.NullLiteral) {
          lex();
          token.value = null;
          return createLiteral(token);
        }
        if (match('[')) {
          return parseArrayInitialiser();
        }
        if (match('{')) {
          return parseObjectInitialiser();
        }
        if (match('(')) {
          return parseGroupExpression();
        }
        if (match('/') || match('/=')) {
          return createLiteral(scanRegExp());
        }
        return throwUnexpected(lex());
      }
      function parseArguments() {
        var args = [];
        expect('(');
        if (!match(')')) {
          while (index < length) {
            args.push(parseAssignmentExpression());
            if (match(')')) {
              break;
            }
            expect(',');
          }
        }
        expect(')');
        return args;
      }
      function parseNonComputedProperty() {
        var token = lex();
        if (!isIdentifierName(token)) {
          throwUnexpected(token);
        }
        return {
          type: Syntax.Identifier,
          name: token.value
        };
      }
      function parseNonComputedMember() {
        expect('.');
        return parseNonComputedProperty();
      }
      function parseComputedMember() {
        var expr;
        expect('[');
        expr = parseExpression();
        expect(']');
        return expr;
      }
      function parseNewExpression() {
        var expr;
        expectKeyword('new');
        expr = {
          type: Syntax.NewExpression,
          callee: parseLeftHandSideExpression(),
          'arguments': []
        };
        if (match('(')) {
          expr['arguments'] = parseArguments();
        }
        return expr;
      }
      function parseLeftHandSideExpressionAllowCall() {
        var expr;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        while (match('.') || match('[') || match('(')) {
          if (match('(')) {
            expr = {
              type: Syntax.CallExpression,
              callee: expr,
              'arguments': parseArguments()
            };
          } else if (match('[')) {
            expr = {
              type: Syntax.MemberExpression,
              computed: true,
              object: expr,
              property: parseComputedMember()
            };
          } else {
            expr = {
              type: Syntax.MemberExpression,
              computed: false,
              object: expr,
              property: parseNonComputedMember()
            };
          }
        }
        return expr;
      }
      function parseLeftHandSideExpression() {
        var expr;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        while (match('.') || match('[')) {
          if (match('[')) {
            expr = {
              type: Syntax.MemberExpression,
              computed: true,
              object: expr,
              property: parseComputedMember()
            };
          } else {
            expr = {
              type: Syntax.MemberExpression,
              computed: false,
              object: expr,
              property: parseNonComputedMember()
            };
          }
        }
        return expr;
      }
      function parsePostfixExpression() {
        var expr = parseLeftHandSideExpressionAllowCall(), token;
        token = lookahead();
        if (token.type !== Token.Punctuator) {
          return expr;
        }
        if ((match('++') || match('--')) && !peekLineTerminator()) {
          if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
            throwErrorTolerant({}, Messages.StrictLHSPostfix);
          }
          if (!isLeftHandSide(expr)) {
            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
          }
          expr = {
            type: Syntax.UpdateExpression,
            operator: lex().value,
            argument: expr,
            prefix: false
          };
        }
        return expr;
      }
      function parseUnaryExpression() {
        var token, expr;
        token = lookahead();
        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
          return parsePostfixExpression();
        }
        if (match('++') || match('--')) {
          token = lex();
          expr = parseUnaryExpression();
          if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
            throwErrorTolerant({}, Messages.StrictLHSPrefix);
          }
          if (!isLeftHandSide(expr)) {
            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
          }
          expr = {
            type: Syntax.UpdateExpression,
            operator: token.value,
            argument: expr,
            prefix: true
          };
          return expr;
        }
        if (match('+') || match('-') || match('~') || match('!')) {
          expr = {
            type: Syntax.UnaryExpression,
            operator: lex().value,
            argument: parseUnaryExpression(),
            prefix: true
          };
          return expr;
        }
        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
          expr = {
            type: Syntax.UnaryExpression,
            operator: lex().value,
            argument: parseUnaryExpression(),
            prefix: true
          };
          if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
            throwErrorTolerant({}, Messages.StrictDelete);
          }
          return expr;
        }
        return parsePostfixExpression();
      }
      function parseMultiplicativeExpression() {
        var expr = parseUnaryExpression();
        while (match('*') || match('/') || match('%')) {
          expr = {
            type: Syntax.BinaryExpression,
            operator: lex().value,
            left: expr,
            right: parseUnaryExpression()
          };
        }
        return expr;
      }
      function parseAdditiveExpression() {
        var expr = parseMultiplicativeExpression();
        while (match('+') || match('-')) {
          expr = {
            type: Syntax.BinaryExpression,
            operator: lex().value,
            left: expr,
            right: parseMultiplicativeExpression()
          };
        }
        return expr;
      }
      function parseShiftExpression() {
        var expr = parseAdditiveExpression();
        while (match('<<') || match('>>') || match('>>>')) {
          expr = {
            type: Syntax.BinaryExpression,
            operator: lex().value,
            left: expr,
            right: parseAdditiveExpression()
          };
        }
        return expr;
      }
      function parseRelationalExpression() {
        var expr, previousAllowIn;
        previousAllowIn = state.allowIn;
        state.allowIn = true;
        expr = parseShiftExpression();
        while (match('<') || match('>') || match('<=') || match('>=') || previousAllowIn && matchKeyword('in') || matchKeyword('instanceof')) {
          expr = {
            type: Syntax.BinaryExpression,
            operator: lex().value,
            left: expr,
            right: parseShiftExpression()
          };
        }
        state.allowIn = previousAllowIn;
        return expr;
      }
      function parseEqualityExpression() {
        var expr = parseRelationalExpression();
        while (match('==') || match('!=') || match('===') || match('!==')) {
          expr = {
            type: Syntax.BinaryExpression,
            operator: lex().value,
            left: expr,
            right: parseRelationalExpression()
          };
        }
        return expr;
      }
      function parseBitwiseANDExpression() {
        var expr = parseEqualityExpression();
        while (match('&')) {
          lex();
          expr = {
            type: Syntax.BinaryExpression,
            operator: '&',
            left: expr,
            right: parseEqualityExpression()
          };
        }
        return expr;
      }
      function parseBitwiseXORExpression() {
        var expr = parseBitwiseANDExpression();
        while (match('^')) {
          lex();
          expr = {
            type: Syntax.BinaryExpression,
            operator: '^',
            left: expr,
            right: parseBitwiseANDExpression()
          };
        }
        return expr;
      }
      function parseBitwiseORExpression() {
        var expr = parseBitwiseXORExpression();
        while (match('|')) {
          lex();
          expr = {
            type: Syntax.BinaryExpression,
            operator: '|',
            left: expr,
            right: parseBitwiseXORExpression()
          };
        }
        return expr;
      }
      function parseLogicalANDExpression() {
        var expr = parseBitwiseORExpression();
        while (match('&&')) {
          lex();
          expr = {
            type: Syntax.LogicalExpression,
            operator: '&&',
            left: expr,
            right: parseBitwiseORExpression()
          };
        }
        return expr;
      }
      function parseLogicalORExpression() {
        var expr = parseLogicalANDExpression();
        while (match('||')) {
          lex();
          expr = {
            type: Syntax.LogicalExpression,
            operator: '||',
            left: expr,
            right: parseLogicalANDExpression()
          };
        }
        return expr;
      }
      function parseConditionalExpression() {
        var expr, previousAllowIn, consequent;
        expr = parseLogicalORExpression();
        if (match('?')) {
          lex();
          previousAllowIn = state.allowIn;
          state.allowIn = true;
          consequent = parseAssignmentExpression();
          state.allowIn = previousAllowIn;
          expect(':');
          expr = {
            type: Syntax.ConditionalExpression,
            test: expr,
            consequent: consequent,
            alternate: parseAssignmentExpression()
          };
        }
        return expr;
      }
      function parseAssignmentExpression() {
        var token, expr;
        token = lookahead();
        expr = parseConditionalExpression();
        if (matchAssign()) {
          if (!isLeftHandSide(expr)) {
            throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
          }
          if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
            throwErrorTolerant(token, Messages.StrictLHSAssignment);
          }
          expr = {
            type: Syntax.AssignmentExpression,
            operator: lex().value,
            left: expr,
            right: parseAssignmentExpression()
          };
        }
        return expr;
      }
      function parseExpression() {
        var expr = parseAssignmentExpression();
        if (match(',')) {
          expr = {
            type: Syntax.SequenceExpression,
            expressions: [expr]
          };
          while (index < length) {
            if (!match(',')) {
              break;
            }
            lex();
            expr.expressions.push(parseAssignmentExpression());
          }
        }
        return expr;
      }
      function parseStatementList() {
        var list = [], statement;
        while (index < length) {
          if (match('}')) {
            break;
          }
          statement = parseSourceElement();
          if (typeof statement === 'undefined') {
            break;
          }
          list.push(statement);
        }
        return list;
      }
      function parseBlock() {
        var block;
        expect('{');
        block = parseStatementList();
        expect('}');
        return {
          type: Syntax.BlockStatement,
          body: block
        };
      }
      function parseVariableIdentifier() {
        var token = lex();
        if (token.type !== Token.Identifier) {
          throwUnexpected(token);
        }
        return {
          type: Syntax.Identifier,
          name: token.value
        };
      }
      function parseVariableDeclaration(kind) {
        var id = parseVariableIdentifier(), init = null;
        if (strict && isRestrictedWord(id.name)) {
          throwErrorTolerant({}, Messages.StrictVarName);
        }
        if (kind === 'const') {
          expect('=');
          init = parseAssignmentExpression();
        } else if (match('=')) {
          lex();
          init = parseAssignmentExpression();
        }
        return {
          type: Syntax.VariableDeclarator,
          id: id,
          init: init
        };
      }
      function parseVariableDeclarationList(kind) {
        var list = [];
        do {
          list.push(parseVariableDeclaration(kind));
          if (!match(',')) {
            break;
          }
          lex();
        } while (index < length);
        return list;
      }
      function parseVariableStatement() {
        var declarations;
        expectKeyword('var');
        declarations = parseVariableDeclarationList();
        consumeSemicolon();
        return {
          type: Syntax.VariableDeclaration,
          declarations: declarations,
          kind: 'var'
        };
      }
      function parseConstLetDeclaration(kind) {
        var declarations;
        expectKeyword(kind);
        declarations = parseVariableDeclarationList(kind);
        consumeSemicolon();
        return {
          type: Syntax.VariableDeclaration,
          declarations: declarations,
          kind: kind
        };
      }
      function parseEmptyStatement() {
        expect(';');
        return { type: Syntax.EmptyStatement };
      }
      function parseExpressionStatement() {
        var expr = parseExpression();
        consumeSemicolon();
        return {
          type: Syntax.ExpressionStatement,
          expression: expr
        };
      }
      function parseIfStatement() {
        var test, consequent, alternate;
        expectKeyword('if');
        expect('(');
        test = parseExpression();
        expect(')');
        consequent = parseStatement();
        if (matchKeyword('else')) {
          lex();
          alternate = parseStatement();
        } else {
          alternate = null;
        }
        return {
          type: Syntax.IfStatement,
          test: test,
          consequent: consequent,
          alternate: alternate
        };
      }
      function parseDoWhileStatement() {
        var body, test, oldInIteration;
        expectKeyword('do');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        expectKeyword('while');
        expect('(');
        test = parseExpression();
        expect(')');
        if (match(';')) {
          lex();
        }
        return {
          type: Syntax.DoWhileStatement,
          body: body,
          test: test
        };
      }
      function parseWhileStatement() {
        var test, body, oldInIteration;
        expectKeyword('while');
        expect('(');
        test = parseExpression();
        expect(')');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        return {
          type: Syntax.WhileStatement,
          test: test,
          body: body
        };
      }
      function parseForVariableDeclaration() {
        var token = lex();
        return {
          type: Syntax.VariableDeclaration,
          declarations: parseVariableDeclarationList(),
          kind: token.value
        };
      }
      function parseForStatement() {
        var init, test, update, left, right, body, oldInIteration;
        init = test = update = null;
        expectKeyword('for');
        expect('(');
        if (match(';')) {
          lex();
        } else {
          if (matchKeyword('var') || matchKeyword('let')) {
            state.allowIn = false;
            init = parseForVariableDeclaration();
            state.allowIn = true;
            if (init.declarations.length === 1 && matchKeyword('in')) {
              lex();
              left = init;
              right = parseExpression();
              init = null;
            }
          } else {
            state.allowIn = false;
            init = parseExpression();
            state.allowIn = true;
            if (matchKeyword('in')) {
              if (!isLeftHandSide(init)) {
                throwErrorTolerant({}, Messages.InvalidLHSInForIn);
              }
              lex();
              left = init;
              right = parseExpression();
              init = null;
            }
          }
          if (typeof left === 'undefined') {
            expect(';');
          }
        }
        if (typeof left === 'undefined') {
          if (!match(';')) {
            test = parseExpression();
          }
          expect(';');
          if (!match(')')) {
            update = parseExpression();
          }
        }
        expect(')');
        oldInIteration = state.inIteration;
        state.inIteration = true;
        body = parseStatement();
        state.inIteration = oldInIteration;
        if (typeof left === 'undefined') {
          return {
            type: Syntax.ForStatement,
            init: init,
            test: test,
            update: update,
            body: body
          };
        }
        return {
          type: Syntax.ForInStatement,
          left: left,
          right: right,
          body: body,
          each: false
        };
      }
      function parseContinueStatement() {
        var token, label = null;
        expectKeyword('continue');
        if (source[index] === ';') {
          lex();
          if (!state.inIteration) {
            throwError({}, Messages.IllegalContinue);
          }
          return {
            type: Syntax.ContinueStatement,
            label: null
          };
        }
        if (peekLineTerminator()) {
          if (!state.inIteration) {
            throwError({}, Messages.IllegalContinue);
          }
          return {
            type: Syntax.ContinueStatement,
            label: null
          };
        }
        token = lookahead();
        if (token.type === Token.Identifier) {
          label = parseVariableIdentifier();
          if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
            throwError({}, Messages.UnknownLabel, label.name);
          }
        }
        consumeSemicolon();
        if (label === null && !state.inIteration) {
          throwError({}, Messages.IllegalContinue);
        }
        return {
          type: Syntax.ContinueStatement,
          label: label
        };
      }
      function parseBreakStatement() {
        var token, label = null;
        expectKeyword('break');
        if (source[index] === ';') {
          lex();
          if (!(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
          }
          return {
            type: Syntax.BreakStatement,
            label: null
          };
        }
        if (peekLineTerminator()) {
          if (!(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
          }
          return {
            type: Syntax.BreakStatement,
            label: null
          };
        }
        token = lookahead();
        if (token.type === Token.Identifier) {
          label = parseVariableIdentifier();
          if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
            throwError({}, Messages.UnknownLabel, label.name);
          }
        }
        consumeSemicolon();
        if (label === null && !(state.inIteration || state.inSwitch)) {
          throwError({}, Messages.IllegalBreak);
        }
        return {
          type: Syntax.BreakStatement,
          label: label
        };
      }
      function parseReturnStatement() {
        var token, argument = null;
        expectKeyword('return');
        if (!state.inFunctionBody) {
          throwErrorTolerant({}, Messages.IllegalReturn);
        }
        if (source[index] === ' ') {
          if (isIdentifierStart(source[index + 1])) {
            argument = parseExpression();
            consumeSemicolon();
            return {
              type: Syntax.ReturnStatement,
              argument: argument
            };
          }
        }
        if (peekLineTerminator()) {
          return {
            type: Syntax.ReturnStatement,
            argument: null
          };
        }
        if (!match(';')) {
          token = lookahead();
          if (!match('}') && token.type !== Token.EOF) {
            argument = parseExpression();
          }
        }
        consumeSemicolon();
        return {
          type: Syntax.ReturnStatement,
          argument: argument
        };
      }
      function parseWithStatement() {
        var object, body;
        if (strict) {
          throwErrorTolerant({}, Messages.StrictModeWith);
        }
        expectKeyword('with');
        expect('(');
        object = parseExpression();
        expect(')');
        body = parseStatement();
        return {
          type: Syntax.WithStatement,
          object: object,
          body: body
        };
      }
      function parseSwitchCase() {
        var test, consequent = [], statement;
        if (matchKeyword('default')) {
          lex();
          test = null;
        } else {
          expectKeyword('case');
          test = parseExpression();
        }
        expect(':');
        while (index < length) {
          if (match('}') || matchKeyword('default') || matchKeyword('case')) {
            break;
          }
          statement = parseStatement();
          if (typeof statement === 'undefined') {
            break;
          }
          consequent.push(statement);
        }
        return {
          type: Syntax.SwitchCase,
          test: test,
          consequent: consequent
        };
      }
      function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound;
        expectKeyword('switch');
        expect('(');
        discriminant = parseExpression();
        expect(')');
        expect('{');
        cases = [];
        if (match('}')) {
          lex();
          return {
            type: Syntax.SwitchStatement,
            discriminant: discriminant,
            cases: cases
          };
        }
        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;
        while (index < length) {
          if (match('}')) {
            break;
          }
          clause = parseSwitchCase();
          if (clause.test === null) {
            if (defaultFound) {
              throwError({}, Messages.MultipleDefaultsInSwitch);
            }
            defaultFound = true;
          }
          cases.push(clause);
        }
        state.inSwitch = oldInSwitch;
        expect('}');
        return {
          type: Syntax.SwitchStatement,
          discriminant: discriminant,
          cases: cases
        };
      }
      function parseThrowStatement() {
        var argument;
        expectKeyword('throw');
        if (peekLineTerminator()) {
          throwError({}, Messages.NewlineAfterThrow);
        }
        argument = parseExpression();
        consumeSemicolon();
        return {
          type: Syntax.ThrowStatement,
          argument: argument
        };
      }
      function parseCatchClause() {
        var param;
        expectKeyword('catch');
        expect('(');
        if (match(')')) {
          throwUnexpected(lookahead());
        }
        param = parseVariableIdentifier();
        if (strict && isRestrictedWord(param.name)) {
          throwErrorTolerant({}, Messages.StrictCatchVariable);
        }
        expect(')');
        return {
          type: Syntax.CatchClause,
          param: param,
          body: parseBlock()
        };
      }
      function parseTryStatement() {
        var block, handlers = [], finalizer = null;
        expectKeyword('try');
        block = parseBlock();
        if (matchKeyword('catch')) {
          handlers.push(parseCatchClause());
        }
        if (matchKeyword('finally')) {
          lex();
          finalizer = parseBlock();
        }
        if (handlers.length === 0 && !finalizer) {
          throwError({}, Messages.NoCatchOrFinally);
        }
        return {
          type: Syntax.TryStatement,
          block: block,
          guardedHandlers: [],
          handlers: handlers,
          finalizer: finalizer
        };
      }
      function parseDebuggerStatement() {
        expectKeyword('debugger');
        consumeSemicolon();
        return { type: Syntax.DebuggerStatement };
      }
      function parseStatement() {
        var token = lookahead(), expr, labeledBody;
        if (token.type === Token.EOF) {
          throwUnexpected(token);
        }
        if (token.type === Token.Punctuator) {
          switch (token.value) {
          case ';':
            return parseEmptyStatement();
          case '{':
            return parseBlock();
          case '(':
            return parseExpressionStatement();
          default:
            break;
          }
        }
        if (token.type === Token.Keyword) {
          switch (token.value) {
          case 'break':
            return parseBreakStatement();
          case 'continue':
            return parseContinueStatement();
          case 'debugger':
            return parseDebuggerStatement();
          case 'do':
            return parseDoWhileStatement();
          case 'for':
            return parseForStatement();
          case 'function':
            return parseFunctionDeclaration();
          case 'if':
            return parseIfStatement();
          case 'return':
            return parseReturnStatement();
          case 'switch':
            return parseSwitchStatement();
          case 'throw':
            return parseThrowStatement();
          case 'try':
            return parseTryStatement();
          case 'var':
            return parseVariableStatement();
          case 'while':
            return parseWhileStatement();
          case 'with':
            return parseWithStatement();
          default:
            break;
          }
        }
        expr = parseExpression();
        if (expr.type === Syntax.Identifier && match(':')) {
          lex();
          if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {
            throwError({}, Messages.Redeclaration, 'Label', expr.name);
          }
          state.labelSet[expr.name] = true;
          labeledBody = parseStatement();
          delete state.labelSet[expr.name];
          return {
            type: Syntax.LabeledStatement,
            label: expr,
            body: labeledBody
          };
        }
        consumeSemicolon();
        return {
          type: Syntax.ExpressionStatement,
          expression: expr
        };
      }
      function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;
        expect('{');
        while (index < length) {
          token = lookahead();
          if (token.type !== Token.StringLiteral) {
            break;
          }
          sourceElement = parseSourceElement();
          sourceElements.push(sourceElement);
          if (sourceElement.expression.type !== Syntax.Literal) {
            break;
          }
          directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
          if (directive === 'use strict') {
            strict = true;
            if (firstRestricted) {
              throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
            }
          } else {
            if (!firstRestricted && token.octal) {
              firstRestricted = token;
            }
          }
        }
        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        while (index < length) {
          if (match('}')) {
            break;
          }
          sourceElement = parseSourceElement();
          if (typeof sourceElement === 'undefined') {
            break;
          }
          sourceElements.push(sourceElement);
        }
        expect('}');
        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        return {
          type: Syntax.BlockStatement,
          body: sourceElements
        };
      }
      function parseFunctionDeclaration() {
        var id, param, params = [], body, token, stricted, firstRestricted, message, previousStrict, paramSet;
        expectKeyword('function');
        token = lookahead();
        id = parseVariableIdentifier();
        if (strict) {
          if (isRestrictedWord(token.value)) {
            throwErrorTolerant(token, Messages.StrictFunctionName);
          }
        } else {
          if (isRestrictedWord(token.value)) {
            firstRestricted = token;
            message = Messages.StrictFunctionName;
          } else if (isStrictModeReservedWord(token.value)) {
            firstRestricted = token;
            message = Messages.StrictReservedWord;
          }
        }
        expect('(');
        if (!match(')')) {
          paramSet = {};
          while (index < length) {
            token = lookahead();
            param = parseVariableIdentifier();
            if (strict) {
              if (isRestrictedWord(token.value)) {
                stricted = token;
                message = Messages.StrictParamName;
              }
              if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                stricted = token;
                message = Messages.StrictParamDupe;
              }
            } else if (!firstRestricted) {
              if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictParamName;
              } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
              } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                firstRestricted = token;
                message = Messages.StrictParamDupe;
              }
            }
            params.push(param);
            paramSet[param.name] = true;
            if (match(')')) {
              break;
            }
            expect(',');
          }
        }
        expect(')');
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
          throwError(firstRestricted, message);
        }
        if (strict && stricted) {
          throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;
        return {
          type: Syntax.FunctionDeclaration,
          id: id,
          params: params,
          defaults: [],
          body: body,
          rest: null,
          generator: false,
          expression: false
        };
      }
      function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, param, params = [], body, previousStrict, paramSet;
        expectKeyword('function');
        if (!match('(')) {
          token = lookahead();
          id = parseVariableIdentifier();
          if (strict) {
            if (isRestrictedWord(token.value)) {
              throwErrorTolerant(token, Messages.StrictFunctionName);
            }
          } else {
            if (isRestrictedWord(token.value)) {
              firstRestricted = token;
              message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
              firstRestricted = token;
              message = Messages.StrictReservedWord;
            }
          }
        }
        expect('(');
        if (!match(')')) {
          paramSet = {};
          while (index < length) {
            token = lookahead();
            param = parseVariableIdentifier();
            if (strict) {
              if (isRestrictedWord(token.value)) {
                stricted = token;
                message = Messages.StrictParamName;
              }
              if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                stricted = token;
                message = Messages.StrictParamDupe;
              }
            } else if (!firstRestricted) {
              if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictParamName;
              } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
              } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                firstRestricted = token;
                message = Messages.StrictParamDupe;
              }
            }
            params.push(param);
            paramSet[param.name] = true;
            if (match(')')) {
              break;
            }
            expect(',');
          }
        }
        expect(')');
        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
          throwError(firstRestricted, message);
        }
        if (strict && stricted) {
          throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;
        return {
          type: Syntax.FunctionExpression,
          id: id,
          params: params,
          defaults: [],
          body: body,
          rest: null,
          generator: false,
          expression: false
        };
      }
      function parseSourceElement() {
        var token = lookahead();
        if (token.type === Token.Keyword) {
          switch (token.value) {
          case 'const':
          case 'let':
            return parseConstLetDeclaration(token.value);
          case 'function':
            return parseFunctionDeclaration();
          default:
            return parseStatement();
          }
        }
        if (token.type !== Token.EOF) {
          return parseStatement();
        }
      }
      function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;
        while (index < length) {
          token = lookahead();
          if (token.type !== Token.StringLiteral) {
            break;
          }
          sourceElement = parseSourceElement();
          sourceElements.push(sourceElement);
          if (sourceElement.expression.type !== Syntax.Literal) {
            break;
          }
          directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
          if (directive === 'use strict') {
            strict = true;
            if (firstRestricted) {
              throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
            }
          } else {
            if (!firstRestricted && token.octal) {
              firstRestricted = token;
            }
          }
        }
        while (index < length) {
          sourceElement = parseSourceElement();
          if (typeof sourceElement === 'undefined') {
            break;
          }
          sourceElements.push(sourceElement);
        }
        return sourceElements;
      }
      function parseProgram() {
        var program;
        strict = false;
        program = {
          type: Syntax.Program,
          body: parseSourceElements()
        };
        return program;
      }
      function addComment(type, value, start, end, loc) {
        assert(typeof start === 'number', 'Comment must have valid position');
        if (extra.comments.length > 0) {
          if (extra.comments[extra.comments.length - 1].range[1] > start) {
            return;
          }
        }
        extra.comments.push({
          type: type,
          value: value,
          range: [
            start,
            end
          ],
          loc: loc
        });
      }
      function scanComment() {
        var comment, ch, loc, start, blockComment, lineComment;
        comment = '';
        blockComment = false;
        lineComment = false;
        while (index < length) {
          ch = source[index];
          if (lineComment) {
            ch = source[index++];
            if (isLineTerminator(ch)) {
              loc.end = {
                line: lineNumber,
                column: index - lineStart - 1
              };
              lineComment = false;
              addComment('Line', comment, start, index - 1, loc);
              if (ch === '\r' && source[index] === '\n') {
                ++index;
              }
              ++lineNumber;
              lineStart = index;
              comment = '';
            } else if (index >= length) {
              lineComment = false;
              comment += ch;
              loc.end = {
                line: lineNumber,
                column: length - lineStart
              };
              addComment('Line', comment, start, length, loc);
            } else {
              comment += ch;
            }
          } else if (blockComment) {
            if (isLineTerminator(ch)) {
              if (ch === '\r' && source[index + 1] === '\n') {
                ++index;
                comment += '\r\n';
              } else {
                comment += ch;
              }
              ++lineNumber;
              ++index;
              lineStart = index;
              if (index >= length) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
            } else {
              ch = source[index++];
              if (index >= length) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
              comment += ch;
              if (ch === '*') {
                ch = source[index];
                if (ch === '/') {
                  comment = comment.substr(0, comment.length - 1);
                  blockComment = false;
                  ++index;
                  loc.end = {
                    line: lineNumber,
                    column: index - lineStart
                  };
                  addComment('Block', comment, start, index, loc);
                  comment = '';
                }
              }
            }
          } else if (ch === '/') {
            ch = source[index + 1];
            if (ch === '/') {
              loc = {
                start: {
                  line: lineNumber,
                  column: index - lineStart
                }
              };
              start = index;
              index += 2;
              lineComment = true;
              if (index >= length) {
                loc.end = {
                  line: lineNumber,
                  column: index - lineStart
                };
                lineComment = false;
                addComment('Line', comment, start, index, loc);
              }
            } else if (ch === '*') {
              start = index;
              index += 2;
              blockComment = true;
              loc = {
                start: {
                  line: lineNumber,
                  column: index - lineStart - 2
                }
              };
              if (index >= length) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
              }
            } else {
              break;
            }
          } else if (isWhiteSpace(ch)) {
            ++index;
          } else if (isLineTerminator(ch)) {
            ++index;
            if (ch === '\r' && source[index] === '\n') {
              ++index;
            }
            ++lineNumber;
            lineStart = index;
          } else {
            break;
          }
        }
      }
      function filterCommentLocation() {
        var i, entry, comment, comments = [];
        for (i = 0; i < extra.comments.length; ++i) {
          entry = extra.comments[i];
          comment = {
            type: entry.type,
            value: entry.value
          };
          if (extra.range) {
            comment.range = entry.range;
          }
          if (extra.loc) {
            comment.loc = entry.loc;
          }
          comments.push(comment);
        }
        extra.comments = comments;
      }
      function collectToken() {
        var start, loc, token, range, value;
        skipComment();
        start = index;
        loc = {
          start: {
            line: lineNumber,
            column: index - lineStart
          }
        };
        token = extra.advance();
        loc.end = {
          line: lineNumber,
          column: index - lineStart
        };
        if (token.type !== Token.EOF) {
          range = [
            token.range[0],
            token.range[1]
          ];
          value = sliceSource(token.range[0], token.range[1]);
          extra.tokens.push({
            type: TokenName[token.type],
            value: value,
            range: range,
            loc: loc
          });
        }
        return token;
      }
      function collectRegex() {
        var pos, loc, regex, token;
        skipComment();
        pos = index;
        loc = {
          start: {
            line: lineNumber,
            column: index - lineStart
          }
        };
        regex = extra.scanRegExp();
        loc.end = {
          line: lineNumber,
          column: index - lineStart
        };
        if (extra.tokens.length > 0) {
          token = extra.tokens[extra.tokens.length - 1];
          if (token.range[0] === pos && token.type === 'Punctuator') {
            if (token.value === '/' || token.value === '/=') {
              extra.tokens.pop();
            }
          }
        }
        extra.tokens.push({
          type: 'RegularExpression',
          value: regex.literal,
          range: [
            pos,
            index
          ],
          loc: loc
        });
        return regex;
      }
      function filterTokenLocation() {
        var i, entry, token, tokens = [];
        for (i = 0; i < extra.tokens.length; ++i) {
          entry = extra.tokens[i];
          token = {
            type: entry.type,
            value: entry.value
          };
          if (extra.range) {
            token.range = entry.range;
          }
          if (extra.loc) {
            token.loc = entry.loc;
          }
          tokens.push(token);
        }
        extra.tokens = tokens;
      }
      function createLiteral(token) {
        return {
          type: Syntax.Literal,
          value: token.value
        };
      }
      function createRawLiteral(token) {
        return {
          type: Syntax.Literal,
          value: token.value,
          raw: sliceSource(token.range[0], token.range[1])
        };
      }
      function createLocationMarker() {
        var marker = {};
        marker.range = [
          index,
          index
        ];
        marker.loc = {
          start: {
            line: lineNumber,
            column: index - lineStart
          },
          end: {
            line: lineNumber,
            column: index - lineStart
          }
        };
        marker.end = function () {
          this.range[1] = index;
          this.loc.end.line = lineNumber;
          this.loc.end.column = index - lineStart;
        };
        marker.applyGroup = function (node) {
          if (extra.range) {
            node.groupRange = [
              this.range[0],
              this.range[1]
            ];
          }
          if (extra.loc) {
            node.groupLoc = {
              start: {
                line: this.loc.start.line,
                column: this.loc.start.column
              },
              end: {
                line: this.loc.end.line,
                column: this.loc.end.column
              }
            };
          }
        };
        marker.apply = function (node) {
          if (extra.range) {
            node.range = [
              this.range[0],
              this.range[1]
            ];
          }
          if (extra.loc) {
            node.loc = {
              start: {
                line: this.loc.start.line,
                column: this.loc.start.column
              },
              end: {
                line: this.loc.end.line,
                column: this.loc.end.column
              }
            };
          }
        };
        return marker;
      }
      function trackGroupExpression() {
        var marker, expr;
        skipComment();
        marker = createLocationMarker();
        expect('(');
        expr = parseExpression();
        expect(')');
        marker.end();
        marker.applyGroup(expr);
        return expr;
      }
      function trackLeftHandSideExpression() {
        var marker, expr;
        skipComment();
        marker = createLocationMarker();
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        while (match('.') || match('[')) {
          if (match('[')) {
            expr = {
              type: Syntax.MemberExpression,
              computed: true,
              object: expr,
              property: parseComputedMember()
            };
            marker.end();
            marker.apply(expr);
          } else {
            expr = {
              type: Syntax.MemberExpression,
              computed: false,
              object: expr,
              property: parseNonComputedMember()
            };
            marker.end();
            marker.apply(expr);
          }
        }
        return expr;
      }
      function trackLeftHandSideExpressionAllowCall() {
        var marker, expr;
        skipComment();
        marker = createLocationMarker();
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
        while (match('.') || match('[') || match('(')) {
          if (match('(')) {
            expr = {
              type: Syntax.CallExpression,
              callee: expr,
              'arguments': parseArguments()
            };
            marker.end();
            marker.apply(expr);
          } else if (match('[')) {
            expr = {
              type: Syntax.MemberExpression,
              computed: true,
              object: expr,
              property: parseComputedMember()
            };
            marker.end();
            marker.apply(expr);
          } else {
            expr = {
              type: Syntax.MemberExpression,
              computed: false,
              object: expr,
              property: parseNonComputedMember()
            };
            marker.end();
            marker.apply(expr);
          }
        }
        return expr;
      }
      function filterGroup(node) {
        var n, i, entry;
        n = Object.prototype.toString.apply(node) === '[object Array]' ? [] : {};
        for (i in node) {
          if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {
            entry = node[i];
            if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {
              n[i] = entry;
            } else {
              n[i] = filterGroup(entry);
            }
          }
        }
        return n;
      }
      function wrapTrackingFunction(range, loc) {
        return function (parseFunction) {
          function isBinary(node) {
            return node.type === Syntax.LogicalExpression || node.type === Syntax.BinaryExpression;
          }
          function visit(node) {
            var start, end;
            if (isBinary(node.left)) {
              visit(node.left);
            }
            if (isBinary(node.right)) {
              visit(node.right);
            }
            if (range) {
              if (node.left.groupRange || node.right.groupRange) {
                start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];
                end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];
                node.range = [
                  start,
                  end
                ];
              } else if (typeof node.range === 'undefined') {
                start = node.left.range[0];
                end = node.right.range[1];
                node.range = [
                  start,
                  end
                ];
              }
            }
            if (loc) {
              if (node.left.groupLoc || node.right.groupLoc) {
                start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;
                end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;
                node.loc = {
                  start: start,
                  end: end
                };
              } else if (typeof node.loc === 'undefined') {
                node.loc = {
                  start: node.left.loc.start,
                  end: node.right.loc.end
                };
              }
            }
          }
          return function () {
            var marker, node;
            skipComment();
            marker = createLocationMarker();
            node = parseFunction.apply(null, arguments);
            marker.end();
            if (range && typeof node.range === 'undefined') {
              marker.apply(node);
            }
            if (loc && typeof node.loc === 'undefined') {
              marker.apply(node);
            }
            if (isBinary(node)) {
              visit(node);
            }
            return node;
          };
        };
      }
      function patch() {
        var wrapTracking;
        if (extra.comments) {
          extra.skipComment = skipComment;
          skipComment = scanComment;
        }
        if (extra.raw) {
          extra.createLiteral = createLiteral;
          createLiteral = createRawLiteral;
        }
        if (extra.range || extra.loc) {
          extra.parseGroupExpression = parseGroupExpression;
          extra.parseLeftHandSideExpression = parseLeftHandSideExpression;
          extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;
          parseGroupExpression = trackGroupExpression;
          parseLeftHandSideExpression = trackLeftHandSideExpression;
          parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;
          wrapTracking = wrapTrackingFunction(extra.range, extra.loc);
          extra.parseAdditiveExpression = parseAdditiveExpression;
          extra.parseAssignmentExpression = parseAssignmentExpression;
          extra.parseBitwiseANDExpression = parseBitwiseANDExpression;
          extra.parseBitwiseORExpression = parseBitwiseORExpression;
          extra.parseBitwiseXORExpression = parseBitwiseXORExpression;
          extra.parseBlock = parseBlock;
          extra.parseFunctionSourceElements = parseFunctionSourceElements;
          extra.parseCatchClause = parseCatchClause;
          extra.parseComputedMember = parseComputedMember;
          extra.parseConditionalExpression = parseConditionalExpression;
          extra.parseConstLetDeclaration = parseConstLetDeclaration;
          extra.parseEqualityExpression = parseEqualityExpression;
          extra.parseExpression = parseExpression;
          extra.parseForVariableDeclaration = parseForVariableDeclaration;
          extra.parseFunctionDeclaration = parseFunctionDeclaration;
          extra.parseFunctionExpression = parseFunctionExpression;
          extra.parseLogicalANDExpression = parseLogicalANDExpression;
          extra.parseLogicalORExpression = parseLogicalORExpression;
          extra.parseMultiplicativeExpression = parseMultiplicativeExpression;
          extra.parseNewExpression = parseNewExpression;
          extra.parseNonComputedProperty = parseNonComputedProperty;
          extra.parseObjectProperty = parseObjectProperty;
          extra.parseObjectPropertyKey = parseObjectPropertyKey;
          extra.parsePostfixExpression = parsePostfixExpression;
          extra.parsePrimaryExpression = parsePrimaryExpression;
          extra.parseProgram = parseProgram;
          extra.parsePropertyFunction = parsePropertyFunction;
          extra.parseRelationalExpression = parseRelationalExpression;
          extra.parseStatement = parseStatement;
          extra.parseShiftExpression = parseShiftExpression;
          extra.parseSwitchCase = parseSwitchCase;
          extra.parseUnaryExpression = parseUnaryExpression;
          extra.parseVariableDeclaration = parseVariableDeclaration;
          extra.parseVariableIdentifier = parseVariableIdentifier;
          parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);
          parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);
          parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);
          parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);
          parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);
          parseBlock = wrapTracking(extra.parseBlock);
          parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);
          parseCatchClause = wrapTracking(extra.parseCatchClause);
          parseComputedMember = wrapTracking(extra.parseComputedMember);
          parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);
          parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);
          parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);
          parseExpression = wrapTracking(extra.parseExpression);
          parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);
          parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);
          parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);
          parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);
          parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);
          parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);
          parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);
          parseNewExpression = wrapTracking(extra.parseNewExpression);
          parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);
          parseObjectProperty = wrapTracking(extra.parseObjectProperty);
          parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);
          parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);
          parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);
          parseProgram = wrapTracking(extra.parseProgram);
          parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);
          parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);
          parseStatement = wrapTracking(extra.parseStatement);
          parseShiftExpression = wrapTracking(extra.parseShiftExpression);
          parseSwitchCase = wrapTracking(extra.parseSwitchCase);
          parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);
          parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);
          parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);
        }
        if (typeof extra.tokens !== 'undefined') {
          extra.advance = advance;
          extra.scanRegExp = scanRegExp;
          advance = collectToken;
          scanRegExp = collectRegex;
        }
      }
      function unpatch() {
        if (typeof extra.skipComment === 'function') {
          skipComment = extra.skipComment;
        }
        if (extra.raw) {
          createLiteral = extra.createLiteral;
        }
        if (extra.range || extra.loc) {
          parseAdditiveExpression = extra.parseAdditiveExpression;
          parseAssignmentExpression = extra.parseAssignmentExpression;
          parseBitwiseANDExpression = extra.parseBitwiseANDExpression;
          parseBitwiseORExpression = extra.parseBitwiseORExpression;
          parseBitwiseXORExpression = extra.parseBitwiseXORExpression;
          parseBlock = extra.parseBlock;
          parseFunctionSourceElements = extra.parseFunctionSourceElements;
          parseCatchClause = extra.parseCatchClause;
          parseComputedMember = extra.parseComputedMember;
          parseConditionalExpression = extra.parseConditionalExpression;
          parseConstLetDeclaration = extra.parseConstLetDeclaration;
          parseEqualityExpression = extra.parseEqualityExpression;
          parseExpression = extra.parseExpression;
          parseForVariableDeclaration = extra.parseForVariableDeclaration;
          parseFunctionDeclaration = extra.parseFunctionDeclaration;
          parseFunctionExpression = extra.parseFunctionExpression;
          parseGroupExpression = extra.parseGroupExpression;
          parseLeftHandSideExpression = extra.parseLeftHandSideExpression;
          parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;
          parseLogicalANDExpression = extra.parseLogicalANDExpression;
          parseLogicalORExpression = extra.parseLogicalORExpression;
          parseMultiplicativeExpression = extra.parseMultiplicativeExpression;
          parseNewExpression = extra.parseNewExpression;
          parseNonComputedProperty = extra.parseNonComputedProperty;
          parseObjectProperty = extra.parseObjectProperty;
          parseObjectPropertyKey = extra.parseObjectPropertyKey;
          parsePrimaryExpression = extra.parsePrimaryExpression;
          parsePostfixExpression = extra.parsePostfixExpression;
          parseProgram = extra.parseProgram;
          parsePropertyFunction = extra.parsePropertyFunction;
          parseRelationalExpression = extra.parseRelationalExpression;
          parseStatement = extra.parseStatement;
          parseShiftExpression = extra.parseShiftExpression;
          parseSwitchCase = extra.parseSwitchCase;
          parseUnaryExpression = extra.parseUnaryExpression;
          parseVariableDeclaration = extra.parseVariableDeclaration;
          parseVariableIdentifier = extra.parseVariableIdentifier;
        }
        if (typeof extra.scanRegExp === 'function') {
          advance = extra.advance;
          scanRegExp = extra.scanRegExp;
        }
      }
      function stringToArray(str) {
        var length = str.length, result = [], i;
        for (i = 0; i < length; ++i) {
          result[i] = str.charAt(i);
        }
        return result;
      }
      function parse(code, options) {
        var program, toString;
        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
          code = toString(code);
        }
        source = code;
        index = 0;
        lineNumber = source.length > 0 ? 1 : 0;
        lineStart = 0;
        length = source.length;
        buffer = null;
        state = {
          allowIn: true,
          labelSet: {},
          inFunctionBody: false,
          inIteration: false,
          inSwitch: false
        };
        extra = {};
        if (typeof options !== 'undefined') {
          extra.range = typeof options.range === 'boolean' && options.range;
          extra.loc = typeof options.loc === 'boolean' && options.loc;
          extra.raw = typeof options.raw === 'boolean' && options.raw;
          if (typeof options.tokens === 'boolean' && options.tokens) {
            extra.tokens = [];
          }
          if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
          }
          if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
          }
        }
        if (length > 0) {
          if (typeof source[0] === 'undefined') {
            if (code instanceof String) {
              source = code.valueOf();
            }
            if (typeof source[0] === 'undefined') {
              source = stringToArray(code);
            }
          }
        }
        patch();
        try {
          program = parseProgram();
          if (typeof extra.comments !== 'undefined') {
            filterCommentLocation();
            program.comments = extra.comments;
          }
          if (typeof extra.tokens !== 'undefined') {
            filterTokenLocation();
            program.tokens = extra.tokens;
          }
          if (typeof extra.errors !== 'undefined') {
            program.errors = extra.errors;
          }
          if (extra.range || extra.loc) {
            program.body = filterGroup(program.body);
          }
        } catch (e) {
          throw e;
        } finally {
          unpatch();
          extra = {};
        }
        return program;
      }
      exports.version = '1.0.4';
      exports.parse = parse;
      exports.Syntax = function () {
        var name, types = {};
        if (typeof Object.create === 'function') {
          types = Object.create(null);
        }
        for (name in Syntax) {
          if (Syntax.hasOwnProperty(name)) {
            types[name] = Syntax[name];
          }
        }
        if (typeof Object.freeze === 'function') {
          Object.freeze(types);
        }
        return types;
      }();
    }));
  });
  global.eslint = require('/lib/eslint.js');
}.call(this, this));
//# sourceMappingURL=build/eslint-min.js.map
